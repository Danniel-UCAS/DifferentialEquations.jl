{
    "docs": [
        {
            "location": "/", 
            "text": "DifferentialEquations.jl Documentation\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see \nODE.jl\n\n\nThis package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.\n\n\nIf at any time you run into documentation that is incomplete/confusing, please contact me via the Gitter channel and I will clear it up!\n\n\n\n\nUsing the Package\n\n\nTo install the package, use the following command inside the Julia REPL:\n\n\nPkg.add(\nDifferentialEquations\n)\n\n\n\n\nFor all of the latest features, switch to the master branch via:\n\n\nPkg.checkout(\nDifferentialEquations\n)\n\n\n\n\nTo load the package, use the command:\n\n\nusing DifferentialEquations\n\n\n\n\nTo understand the package in more detail, check out the following tutorials. Example codes for the latest features can be found in \ntest/\n. Note that for many of the examples in the test folder, you may wish to run them at lower \u0394x or \u0394t. These values were taken to be large in order make unit tests run faster!\n\n\nFor the most up to date on using the package information, please contact me \nvia the repository Gitter\n or \nread the latest documentation\n\n\n\n\nTutorials\n\n\nThe following tutorials will introduce you to the functionality of DifferentialEquations.jl\n\n\n\n\nPoisson Equation Finite Element Method Example\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\n\n\n\n\nManual\n\n\n\n\nOverview of DifferentialEquations.jl Usage\n\n\nDefining a Problem\n\n\nPoisson Equation Problem\n\n\nHeat Equation Problem\n\n\nExample Problems\n\n\nRelated Functions\n\n\n\n\n\n\nMeshes\n\n\nMesh Specification\n\n\nMesh Type\n\n\nMesh Generation Functions\n\n\nExample Meshes\n\n\n\n\n\n\nInformation on Solvers\n\n\nFinite Element Method Solvers\n\n\n\n\n\n\nThe Solution Type\n\n\nRelated Functions\n\n\n\n\n\n\nPlot Functions\n\n\nRelated Functions\n\n\n\n\n\n\nConvergence Simulations\n\n\nThe ConvergenceSimulation Type\n\n\nRelated Functions\n\n\nPlot Functions\n\n\n\n\n\n\n\n\n\n\nInternal Documentation\n\n\n\n\nInternal Finite Element Tools\n\n\nGeneral\n\n\nMesh Tools\n\n\nSolver Tools\n\n\nError Tools\n\n\n\n\n\n\nExtra Functions\n\n\n\n\n\n\nIndex\n\n\n\n\nDifferentialEquations.checkIfLoaded\n\n\nDifferentialEquations.getNoise\n\n\nDifferentialEquations.modulechildren\n\n\nDifferentialEquations.numparameters\n\n\nDifferentialEquations\n\n\nDifferentialEquations.CFL\u03bc\n\n\nDifferentialEquations.CFL\u03bd\n\n\nDifferentialEquations.accumarray\n\n\nDifferentialEquations.assemblematrix\n\n\nDifferentialEquations.getH1error\n\n\nDifferentialEquations.getL2error\n\n\nDifferentialEquations.meshgrid\n\n\nDifferentialEquations.quadfbasis\n\n\nDifferentialEquations.quadpts\n\n\nDifferentialEquations.quadpts1\n\n\nDifferentialEquations.\u2207basis\n\n\nDifferentialEquations.\u2207u\n\n\nBase.length\n\n\nDifferentialEquations.ConvergenceSimulation\n\n\nDifferentialEquations.conv_ests\n\n\nDifferentialEquations.convplot_full\u0394t\n\n\nDifferentialEquations.convplot_full\u0394x\n\n\nDifferentialEquations.convplot_h1vs\u0394t\n\n\nDifferentialEquations.convplot_h1vs\u0394x\n\n\nDifferentialEquations.convplot_l2vs\u0394t\n\n\nDifferentialEquations.convplot_l2vs\u0394x\n\n\nDifferentialEquations.convplot_maxvs\u0394t\n\n\nDifferentialEquations.convplot_maxvs\u0394x\n\n\nDifferentialEquations.convplot_node2vs\u0394t\n\n\nDifferentialEquations.convplot_node2vs\u0394x\n\n\nDifferentialEquations.FEMmesh\n\n\nDifferentialEquations.Mesh\n\n\nDifferentialEquations.SimpleMesh\n\n\nDifferentialEquations.fem_squaremesh\n\n\nDifferentialEquations.findboundary\n\n\nDifferentialEquations.meshExample_Lshapemesh\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n\n\nDifferentialEquations.meshExample_bunny\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n\n\nDifferentialEquations.meshExample_lakemesh\n\n\nDifferentialEquations.meshExample_oilpump\n\n\nDifferentialEquations.meshExample_wavymesh\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n\n\nDifferentialEquations.notime_squaremesh\n\n\nDifferentialEquations.parabolic_squaremesh\n\n\nDifferentialEquations.setboundary\n\n\nDifferentialEquations.convplot\n\n\nDifferentialEquations.showmesh\n\n\nDifferentialEquations.solplot\n\n\nDifferentialEquations.solplot_animation\n\n\nDifferentialEquations.solplot_appx\n\n\nDifferentialEquations.solplot_appxvstrue\n\n\nDifferentialEquations.HeatProblem\n\n\nDifferentialEquations.PdeProblem\n\n\nDifferentialEquations.PoissonProblem\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n\n\nDifferentialEquations.heatProblemExample_diffuse\n\n\nDifferentialEquations.heatProblemExample_moving\n\n\nDifferentialEquations.heatProblemExample_pure\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n\n\nDifferentialEquations.poissonProblemExample_wave\n\n\nDifferentialEquations.FEMSolution\n\n\nDifferentialEquations.PdeSolution\n\n\nDifferentialEquations.appxTrue!\n\n\nDifferentialEquations.fem_solveheat\n\n\nDifferentialEquations.fem_solvepoisson", 
            "title": "Introduction"
        }, 
        {
            "location": "/#differentialequationsjl-documentation", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see  ODE.jl  This package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.  If at any time you run into documentation that is incomplete/confusing, please contact me via the Gitter channel and I will clear it up!", 
            "title": "DifferentialEquations.jl Documentation"
        }, 
        {
            "location": "/#using-the-package", 
            "text": "To install the package, use the following command inside the Julia REPL:  Pkg.add( DifferentialEquations )  For all of the latest features, switch to the master branch via:  Pkg.checkout( DifferentialEquations )  To load the package, use the command:  using DifferentialEquations  To understand the package in more detail, check out the following tutorials. Example codes for the latest features can be found in  test/ . Note that for many of the examples in the test folder, you may wish to run them at lower \u0394x or \u0394t. These values were taken to be large in order make unit tests run faster!  For the most up to date on using the package information, please contact me  via the repository Gitter  or  read the latest documentation", 
            "title": "Using the Package"
        }, 
        {
            "location": "/#tutorials", 
            "text": "The following tutorials will introduce you to the functionality of DifferentialEquations.jl   Poisson Equation Finite Element Method Example  Heat Equation Finite Element Method Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#manual", 
            "text": "Overview of DifferentialEquations.jl Usage  Defining a Problem  Poisson Equation Problem  Heat Equation Problem  Example Problems  Related Functions    Meshes  Mesh Specification  Mesh Type  Mesh Generation Functions  Example Meshes    Information on Solvers  Finite Element Method Solvers    The Solution Type  Related Functions    Plot Functions  Related Functions    Convergence Simulations  The ConvergenceSimulation Type  Related Functions  Plot Functions", 
            "title": "Manual"
        }, 
        {
            "location": "/#internal-documentation", 
            "text": "Internal Finite Element Tools  General  Mesh Tools  Solver Tools  Error Tools    Extra Functions", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "DifferentialEquations.checkIfLoaded  DifferentialEquations.getNoise  DifferentialEquations.modulechildren  DifferentialEquations.numparameters  DifferentialEquations  DifferentialEquations.CFL\u03bc  DifferentialEquations.CFL\u03bd  DifferentialEquations.accumarray  DifferentialEquations.assemblematrix  DifferentialEquations.getH1error  DifferentialEquations.getL2error  DifferentialEquations.meshgrid  DifferentialEquations.quadfbasis  DifferentialEquations.quadpts  DifferentialEquations.quadpts1  DifferentialEquations.\u2207basis  DifferentialEquations.\u2207u  Base.length  DifferentialEquations.ConvergenceSimulation  DifferentialEquations.conv_ests  DifferentialEquations.convplot_full\u0394t  DifferentialEquations.convplot_full\u0394x  DifferentialEquations.convplot_h1vs\u0394t  DifferentialEquations.convplot_h1vs\u0394x  DifferentialEquations.convplot_l2vs\u0394t  DifferentialEquations.convplot_l2vs\u0394x  DifferentialEquations.convplot_maxvs\u0394t  DifferentialEquations.convplot_maxvs\u0394x  DifferentialEquations.convplot_node2vs\u0394t  DifferentialEquations.convplot_node2vs\u0394x  DifferentialEquations.FEMmesh  DifferentialEquations.Mesh  DifferentialEquations.SimpleMesh  DifferentialEquations.fem_squaremesh  DifferentialEquations.findboundary  DifferentialEquations.meshExample_Lshapemesh  DifferentialEquations.meshExample_Lshapeunstructure  DifferentialEquations.meshExample_bunny  DifferentialEquations.meshExample_flowpastcylindermesh  DifferentialEquations.meshExample_lakemesh  DifferentialEquations.meshExample_oilpump  DifferentialEquations.meshExample_wavymesh  DifferentialEquations.meshExample_wavyperturbmesh  DifferentialEquations.notime_squaremesh  DifferentialEquations.parabolic_squaremesh  DifferentialEquations.setboundary  DifferentialEquations.convplot  DifferentialEquations.showmesh  DifferentialEquations.solplot  DifferentialEquations.solplot_animation  DifferentialEquations.solplot_appx  DifferentialEquations.solplot_appxvstrue  DifferentialEquations.HeatProblem  DifferentialEquations.PdeProblem  DifferentialEquations.PoissonProblem  DifferentialEquations.heatProblemExample_birthdeath  DifferentialEquations.heatProblemExample_diffuse  DifferentialEquations.heatProblemExample_moving  DifferentialEquations.heatProblemExample_pure  DifferentialEquations.heatProblemExample_stochasticbirthdeath  DifferentialEquations.poissonProblemExample_birthdeath  DifferentialEquations.poissonProblemExample_noisyWave  DifferentialEquations.poissonProblemExample_wave  DifferentialEquations.FEMSolution  DifferentialEquations.PdeSolution  DifferentialEquations.appxTrue!  DifferentialEquations.fem_solveheat  DifferentialEquations.fem_solvepoisson", 
            "title": "Index"
        }, 
        {
            "location": "/tutorials/femPoisson/", 
            "text": "Poisson Equation Finite Element Method Example\n\n\nIn this example we will solve the Poisson Equation \n$\u0394u=f$\n. The code for this example can be found in \ntest/introductionExample.jl\n. For our example, we will take the linear equation where \nf(x,y) = sin(2\u03c0.*x).*cos(2\u03c0.*y)\n. For this equation we know that solution is \nu(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n with gradient \nDu(x,y) = [cos(2*pi.*x).*cos(2*pi.*y)./(4*pi) -sin(2\u03c0.*x).*sin(2\u03c0.*y)./(4\u03c0)]\n. Thus, we define a PoissonProblem as follows:\n\n\nExample problem with solution: ``u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)``\n\nfunction poissonProblemExample_wave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  return(PoissonProblem(f,sol,Du,gN,isLinear))\nend\npdeProb = poissonProblemExample_wave()\n\n\n\n\nNote that in this case since the solution is known, the Dirichlet boundary condition \ngD\n is automatically set to match the true solution. The code for other example problems can be found in \nsrc/examples/exampleProblems.jl\n. To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:\n\n\n\u0394x = 1//2^(5)\nfemMesh = notime_squaremesh([0 1 0 1],\u0394x,\nDirichlet\n)\n\n\n\n\nNote that by specifying \"Dirichlet\" our boundary conditions is set on all boundaries to Dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as \niFEM\n. Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use\n\n\nres = fem_solvepoisson(femMesh::FEMmesh,pdeProb::PoissonProblem,solver=\nGMRES\n)\n\n\n\n\nfem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This reurns a FEMSolution object which holds data about the solution, such as the solution values (u), the true solution (uTrue), error estimates, etc. To plot the solution, we use the command\n\n\nsolplot(res,savefile=\nintroductionExample.png\n)\n\n\n\n\nThis gives us the following plot:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femPoisson/#poisson-equation-finite-element-method-example", 
            "text": "In this example we will solve the Poisson Equation  $\u0394u=f$ . The code for this example can be found in  test/introductionExample.jl . For our example, we will take the linear equation where  f(x,y) = sin(2\u03c0.*x).*cos(2\u03c0.*y) . For this equation we know that solution is  u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  with gradient  Du(x,y) = [cos(2*pi.*x).*cos(2*pi.*y)./(4*pi) -sin(2\u03c0.*x).*sin(2\u03c0.*y)./(4\u03c0)] . Thus, we define a PoissonProblem as follows:  Example problem with solution: ``u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)`` \nfunction poissonProblemExample_wave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  return(PoissonProblem(f,sol,Du,gN,isLinear))\nend\npdeProb = poissonProblemExample_wave()  Note that in this case since the solution is known, the Dirichlet boundary condition  gD  is automatically set to match the true solution. The code for other example problems can be found in  src/examples/exampleProblems.jl . To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:  \u0394x = 1//2^(5)\nfemMesh = notime_squaremesh([0 1 0 1],\u0394x, Dirichlet )  Note that by specifying \"Dirichlet\" our boundary conditions is set on all boundaries to Dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as  iFEM . Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use  res = fem_solvepoisson(femMesh::FEMmesh,pdeProb::PoissonProblem,solver= GMRES )  fem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This reurns a FEMSolution object which holds data about the solution, such as the solution values (u), the true solution (uTrue), error estimates, etc. To plot the solution, we use the command  solplot(res,savefile= introductionExample.png )  This gives us the following plot:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femHeat/", 
            "text": "Heat Equation Finite Element Method Example\n\n\nIn this example we will solve the heat equation \nu_t=\u0394u+f\n. To do this, we define a HeatProblem which contains the function \nf\n and the boundary conditions. We specify one as follows:\n\n\nExample problem which starts with 0 and solves with f(u)=1-.1u\n\nfunction heatProblemExample_birthdeath()\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  return(HeatProblem(u0,f))\nend\npdeProb = heatProblemExample_birthdeath()\n\n\n\n\nHere the equation we chose was nonlinear since \nf\n depends on the variable \nu\n. Thus we specify f=f(u,x,t). If \nf\n did not depend on u, then we would specify f=f(x,t). We do need to specify \ngD\n (the Dirichlet boundary condition) and \ngN\n (the Neumann boundary condition) since both are zero. \nu0\n specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.\n\n\nWe then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command\n\n\nT = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,\nDirichlet\n)\n\n\n\n\nWe then call the appropriate solver\n\n\nres = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg=\nEuler\n)\n\n\n\n\nHere we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femHeat/#heat-equation-finite-element-method-example", 
            "text": "In this example we will solve the heat equation  u_t=\u0394u+f . To do this, we define a HeatProblem which contains the function  f  and the boundary conditions. We specify one as follows:  Example problem which starts with 0 and solves with f(u)=1-.1u \nfunction heatProblemExample_birthdeath()\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  return(HeatProblem(u0,f))\nend\npdeProb = heatProblemExample_birthdeath()  Here the equation we chose was nonlinear since  f  depends on the variable  u . Thus we specify f=f(u,x,t). If  f  did not depend on u, then we would specify f=f(x,t). We do need to specify  gD  (the Dirichlet boundary condition) and  gN  (the Neumann boundary condition) since both are zero.  u0  specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.  We then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command  T = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T, Dirichlet )  We then call the appropriate solver  res = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg= Euler )  Here we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femStochastic/", 
            "text": "Stochastic Finite Element Examples\n\n\nFor most problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments \ndW\n, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noiseType which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.\n\n\nThe following examples show how to change the tutorial problems into stochastic problems.\n\n\n\n\nFinite Element Stochastic Poisson Equation\n\n\nWe can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  \n-\u0394u=f+gdW\n, with additive space-time white noise by specifying the problem as:\n\n\nExample problem with deterministic solution: u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\nfunction poissonProblemExample_noisyWave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  stochastic = true\n  \u03c3(x) = 5 #Additive noise, a big amount!\n  return(PoissonProblem(f,sol,Du,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend\n\n\n\n\nusing the same solving commands as shown in \nfemStochasticPoissonSolo.jl\n. This gives the following plot:\n\n\n\n\n\n\nFinite Element Stochastic Heat Equation\n\n\nThis will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function \nf(u)=.5-u\n, noise function \ng(u)=100u^2\n and initial condition \nu0=0\n. We would expect this system to rise towards the deterministic steady state \nu=2\n (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:\n\n\nExample problem which starts with 0 and solves with f(u)=1-.1u\n\nfunction heatProblemExample_stochasticbirthdeath()\n  gD(x,t) = zeros(size(x,1))\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  gN(x,t) = 0\n  isLinear = false\n  stochastic = true\n  \u03c3(u,x,t) = 100u.^2\n  return(HeatProblem(u0,f,gD,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend\n\n\n\n\nAs shown in \nfemStochasticHeatAnimationTest.jl\n, we use the following code create an animation of the solution:\n\n\nT = 5\n\u0394x = 1//2^(4)\n\u0394t = 1//2^(12)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,\nNeumann\n)\npdeProb = heatProblemExample_stochasticbirthdeath()\n\nres = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg=\nEuler\n,fullSave=true)\nsolplot_animation(res::FEMSolution;zlim=(0,2),vmax=.1,cbar=false)", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femStochastic/#stochastic-finite-element-examples", 
            "text": "For most problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments  dW , and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noiseType which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.  The following examples show how to change the tutorial problems into stochastic problems.", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femStochastic/#finite-element-stochastic-poisson-equation", 
            "text": "We can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,   -\u0394u=f+gdW , with additive space-time white noise by specifying the problem as:  Example problem with deterministic solution: u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0) \nfunction poissonProblemExample_noisyWave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  stochastic = true\n  \u03c3(x) = 5 #Additive noise, a big amount!\n  return(PoissonProblem(f,sol,Du,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend  using the same solving commands as shown in  femStochasticPoissonSolo.jl . This gives the following plot:", 
            "title": "Finite Element Stochastic Poisson Equation"
        }, 
        {
            "location": "/tutorials/femStochastic/#finite-element-stochastic-heat-equation", 
            "text": "This will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function  f(u)=.5-u , noise function  g(u)=100u^2  and initial condition  u0=0 . We would expect this system to rise towards the deterministic steady state  u=2  (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:  Example problem which starts with 0 and solves with f(u)=1-.1u \nfunction heatProblemExample_stochasticbirthdeath()\n  gD(x,t) = zeros(size(x,1))\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  gN(x,t) = 0\n  isLinear = false\n  stochastic = true\n  \u03c3(u,x,t) = 100u.^2\n  return(HeatProblem(u0,f,gD,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend  As shown in  femStochasticHeatAnimationTest.jl , we use the following code create an animation of the solution:  T = 5\n\u0394x = 1//2^(4)\n\u0394t = 1//2^(12)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T, Neumann )\npdeProb = heatProblemExample_stochasticbirthdeath()\n\nres = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg= Euler ,fullSave=true)\nsolplot_animation(res::FEMSolution;zlim=(0,2),vmax=.1,cbar=false)", 
            "title": "Finite Element Stochastic Heat Equation"
        }, 
        {
            "location": "/man/overview/", 
            "text": "Overview of DifferentialEquations.jl Usage\n\n\nThe general workflow for using the package is as follows:\n\n\n\n\nDefine a problem\n\n\nGenerate a mesh\n\n\nUse a solver on the problem and mesh\n\n\nAnalyze the output\n\n\n\n\nProblems are specified via a type interface. For example, for the Poisson equation \n\u0394u = f\n, one defines a type which holds \nf\n and the boundary condition functions.\n\n\nNext, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. [0,1]^2 x [0,T], then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.\n\n\nOne then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.\n\n\nWith the solution object, you do the analysis as you please! For some result \nres\n, the field \nres.u\n returns the final solution, and if you give a true solution, \nres.uTrue\n is the true solution at the final time. If you specified to the solver \nfullSave=true\n, then \nres.uFull\n and \nres.tFull\n will be outputted which hold the solution/time at every \nsaveSteps\n (default set to 100, meaning it saves an output every 100 steps).\n\n\nHowever, DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. Various plotter functions take in result types and use these to make standard plots. If \nfullSave\n was used, the plotters can generate animations of the solutions to evolution equations.  An array of solutions can be made into a \nConvergenceSimulation\n which then generates all of the convergence test results and allows for plotting (great for developing new methods!).", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#overview-of-differentialequationsjl-usage", 
            "text": "The general workflow for using the package is as follows:   Define a problem  Generate a mesh  Use a solver on the problem and mesh  Analyze the output   Problems are specified via a type interface. For example, for the Poisson equation  \u0394u = f , one defines a type which holds  f  and the boundary condition functions.  Next, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. [0,1]^2 x [0,T], then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.  One then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.  With the solution object, you do the analysis as you please! For some result  res , the field  res.u  returns the final solution, and if you give a true solution,  res.uTrue  is the true solution at the final time. If you specified to the solver  fullSave=true , then  res.uFull  and  res.tFull  will be outputted which hold the solution/time at every  saveSteps  (default set to 100, meaning it saves an output every 100 steps).  However, DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. Various plotter functions take in result types and use these to make standard plots. If  fullSave  was used, the plotters can generate animations of the solutions to evolution equations.  An array of solutions can be made into a  ConvergenceSimulation  which then generates all of the convergence test results and allows for plotting (great for developing new methods!).", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/problem/", 
            "text": "Defining a Problem\n\n\nBelow are the definitions of the types which specify problems. Some general notes are:\n\n\n\n\n(x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as \nf(x,y,t)\n. However, in this code we use \nx\n as a vector. Thus you can think of \nx\n=\nx[:,1]\n and \ny\n=\nx[:,2]\n. Thus input equations are of the form \nf(x,t)\n no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use \nf(x)\n. An example is the equation \nu(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n would be specified as \nsol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n.\n\n\nLinearity: If the equation has linear term, they are specified with functions \nf(x,t)\n. If it is nonlinear, it is specified with functions \nf(u,x,t)\n. The boundary conditions are always \n(x,t)\n\n\nStochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic \n\u03c3(u,x,t)dW_t\n term to the equation (or with \n\u03c3(x,t)dW_t\n if linear, must match \nf\n). \ndW_t\n corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.\n\n\n\n\n\n\nPoisson Equation Problem\n\n\n#\n\n\nDifferentialEquations.PoissonProblem\n \n \nType\n.\n\n\nPoissonProblem\n\n\nWraps the data that define a 2D linear Poisson equation problem:\n\n\n-\u0394u = f\n\n\n\n\nwith bounday conditions \ngD\n on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\n-\u0394u = f + \u03c3dW\n\n\n\n\nConstructors\n\n\nPoissonProblem(f,sol,Du): Defines the Dirichlet problem with solution \nsol\n, solution gradient \nDu = [u_x,u_y]\n, and forcing function \nf\n\n\nPoissonProblem(u\u2080,f): Defines the problem with initial value \nu\u2080\n (as a function) and f. If your initial data is a vector, wrap it as u\u2080(x) = vector.\n\n\nNote: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))\n\n\nKeyword Arguments\n\n\n\n\n\n\ngD\n = Dirichlet boundary function\n\n\n\n\n\n\ngN\n = Neumann boundary function\n\n\n\n\n\n\n\u03c3\n = The function which multiplies the noise \ndW\n. By default \n\u03c3\n is 0.\n\n\n\n\n\n\nnoiseType\n = A string which specifies the type of noise to be generated. By default \nnoiseType\n is \"White\" for Gaussian Spacetime White Noise.\n\n\n\n\n\n\n\n\nHeat Equation Problem\n\n\n#\n\n\nDifferentialEquations.HeatProblem\n \n \nType\n.\n\n\nHeatProblem\n\n\nWraps the data that define a 2D heat equation problem:\n\n\nu_t = \u0394u + f\n\n\n\n\nwith bounday conditions \ngD\n on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\nu_t = \u0394u + f + \u03c3dW_t\n\n\n\n\nConstructors\n\n\n\n\n\n\nHeatProblem(sol,Du,f)\n: Defines the Dirichlet problem with solution \nsol\n, solution gradient \nDu = [u_x,u_y]\n, and the forcing function \nf\n.\n\n\n\n\n\n\nHeatProblem(u\u2080,f)\n: Defines the problem with initial value \nu\u2080\n (as a function) and \nf\n. If your initial data is a vector, wrap it as u\u2080(x) = vector.\n\n\n\n\n\n\nNote: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))\n\n\nKeyword Arguments\n\n\n\n\n\n\ngD\n = Dirichlet boundary function\n\n\n\n\n\n\ngN\n = Neumann boundary function\n\n\n\n\n\n\n\u03c3\n = The function which multiplies the noise dW. By default \u03c3 is 0.\n\n\n\n\n\n\nnoiseType\n = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.\n\n\n\n\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_wave\n \n \nFunction\n.\n\n\nExample problem with solution: \nu(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n \n \nFunction\n.\n\n\nExample problem with deterministic solution: \nu(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem for nonlinear Poisson equation. Uses \nf(u)=1-u/2\n.\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffuse\n \n \nFunction\n.\n\n\nExample problem with solution: \nu(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_pure\n \n \nFunction\n.\n\n\nExample problem which starts with 1 at (0.5,0.5) and solves with \nf=gD=0\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_moving\n \n \nFunction\n.\n\n\nExample problem with solution: \nu(x,y,t)=0.1*(1-exp(-100*(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with \nf(u)=1-u/2\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with \nf(u)=1-u/2\n with noise \n\u03c3(u)=10u^2\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.PdeProblem\n \n \nType\n.\n\n\nPdeProblem: Defines PDE problems via its internal functions", 
            "title": "Defining a Problem"
        }, 
        {
            "location": "/man/problem/#defining-a-problem", 
            "text": "Below are the definitions of the types which specify problems. Some general notes are:   (x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as  f(x,y,t) . However, in this code we use  x  as a vector. Thus you can think of  x = x[:,1]  and  y = x[:,2] . Thus input equations are of the form  f(x,t)  no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use  f(x) . An example is the equation  u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  would be specified as  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0) .  Linearity: If the equation has linear term, they are specified with functions  f(x,t) . If it is nonlinear, it is specified with functions  f(u,x,t) . The boundary conditions are always  (x,t)  Stochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic  \u03c3(u,x,t)dW_t  term to the equation (or with  \u03c3(x,t)dW_t  if linear, must match  f ).  dW_t  corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.", 
            "title": "Defining a Problem"
        }, 
        {
            "location": "/man/problem/#poisson-equation-problem", 
            "text": "#  DifferentialEquations.PoissonProblem     Type .  PoissonProblem  Wraps the data that define a 2D linear Poisson equation problem:  -\u0394u = f  with bounday conditions  gD  on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  -\u0394u = f + \u03c3dW", 
            "title": "Poisson Equation Problem"
        }, 
        {
            "location": "/man/problem/#constructors", 
            "text": "PoissonProblem(f,sol,Du): Defines the Dirichlet problem with solution  sol , solution gradient  Du = [u_x,u_y] , and forcing function  f  PoissonProblem(u\u2080,f): Defines the problem with initial value  u\u2080  (as a function) and f. If your initial data is a vector, wrap it as u\u2080(x) = vector.  Note: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/problem/#keyword-arguments", 
            "text": "gD  = Dirichlet boundary function    gN  = Neumann boundary function    \u03c3  = The function which multiplies the noise  dW . By default  \u03c3  is 0.    noiseType  = A string which specifies the type of noise to be generated. By default  noiseType  is \"White\" for Gaussian Spacetime White Noise.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/problem/#heat-equation-problem", 
            "text": "#  DifferentialEquations.HeatProblem     Type .  HeatProblem  Wraps the data that define a 2D heat equation problem:  u_t = \u0394u + f  with bounday conditions  gD  on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  u_t = \u0394u + f + \u03c3dW_t", 
            "title": "Heat Equation Problem"
        }, 
        {
            "location": "/man/problem/#constructors_1", 
            "text": "HeatProblem(sol,Du,f) : Defines the Dirichlet problem with solution  sol , solution gradient  Du = [u_x,u_y] , and the forcing function  f .    HeatProblem(u\u2080,f) : Defines the problem with initial value  u\u2080  (as a function) and  f . If your initial data is a vector, wrap it as u\u2080(x) = vector.    Note: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/problem/#keyword-arguments_1", 
            "text": "gD  = Dirichlet boundary function    gN  = Neumann boundary function    \u03c3  = The function which multiplies the noise dW. By default \u03c3 is 0.    noiseType  = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/problem/#example-problems", 
            "text": "#  DifferentialEquations.poissonProblemExample_wave     Function .  Example problem with solution:  u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  #  DifferentialEquations.poissonProblemExample_noisyWave     Function .  Example problem with deterministic solution:  u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  #  DifferentialEquations.poissonProblemExample_birthdeath     Function .  Example problem for nonlinear Poisson equation. Uses  f(u)=1-u/2 .  #  DifferentialEquations.heatProblemExample_diffuse     Function .  Example problem with solution:  u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)  #  DifferentialEquations.heatProblemExample_pure     Function .  Example problem which starts with 1 at (0.5,0.5) and solves with  f=gD=0  #  DifferentialEquations.heatProblemExample_moving     Function .  Example problem with solution:  u(x,y,t)=0.1*(1-exp(-100*(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))  #  DifferentialEquations.heatProblemExample_birthdeath     Function .  Example problem which starts with 0 and solves with  f(u)=1-u/2  #  DifferentialEquations.heatProblemExample_stochasticbirthdeath     Function .  Example problem which starts with 0 and solves with  f(u)=1-u/2  with noise  \u03c3(u)=10u^2", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/problem/#related-functions", 
            "text": "#  DifferentialEquations.PdeProblem     Type .  PdeProblem: Defines PDE problems via its internal functions", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/mesh/", 
            "text": "Meshes\n\n\n\n\nMesh Specification\n\n\nFinite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:\n\n\n\n\nRow \ni\n of node is an \n(x,y)\n (or \n(x,y,z)\n) pair which specifies the coordinates of the \ni\nth node.\n\n\nRow \nj\n of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.\n\n\n\n\nFor example, to know the \n(x,y)\n locations of the vertices of triangle \nj\n, we would see that \nnode[elem[j,i],:]\n are the \n(x,y)\n locations of the \ni\nth vertex for \ni=1,2,3\n.\n\n\nFor more information, please see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\n\n\nMesh Type\n\n\n#\n\n\nDifferentialEquations.FEMmesh\n \n \nType\n.\n\n\nFEMmesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\nbdNode\n: Vector of indices for the boundary nodes.\n\n\nfreeNode\n: Vector of indices for the free (non-Dirichlet bound) nodes.\n\n\nbdEdge\n: Indices of the edges in totalEdge which are on the boundary.\n\n\nisBdNode\n: Boolean which is true for nodes on the boundary.\n\n\nisBdElem\n: Boolean which is true for elements on the boundary.\n\n\nbdFlag\n: Flag which describes the type of boundary condition. 1=\n Dirichlet, 2=\nNeumann, 3=\nRobin.\n\n\ntotalEdge\n: Vector of the edges.\n\n\narea\n: Vector which is the area for each element.\n\n\nDirichlet\n: Indices for the nodes on the boundary which have a Dirichlet boundary condition.\n\n\nNeumann\n: Indices for the nodes on the boundary which have a Neumann boundary condition.\n\n\nRobin\n: Indices for the nodes on the boundary which have a Robin boundary condition.\n\n\nN::Int\n: The number of nodes.\n\n\nNT\n::Int: The number of triangles (elements).\n\n\n\u0394x\n: The spatial discretization size. If non-uniform, this is the average.\n\n\n\u0394t\n: The time discretization size. If adaptive, this is the initial.\n\n\nT\n::Number: The end time.\n\n\nnumIters\n::Int: The number of iterations to go from 0 to T using \u0394t.\n\n\n\u03bc\n: The CFL \u03bc stability parameter.\n\n\n\u03bd\n: The CFL \u03bd stability parameter.\n\n\nevolutionEq\n: True for a mesh which has non-trivial time components.\n\n\n\n\n#\n\n\nDifferentialEquations.SimpleMesh\n \n \nType\n.\n\n\nSimpleMesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\n\n\n#\n\n\nDifferentialEquations.Mesh\n \n \nType\n.\n\n\nMesh: An abstract type which holds a (node,elem) pair and other information for a mesh\n\n\n\n\nMesh Generation Functions\n\n\n#\n\n\nDifferentialEquations.findboundary\n \n \nFunction\n.\n\n\nfindboundary(elem,bdFlag=[])\n\n\nfindboundary(femMesh::FEMmesh,bdFlag=[])\n\n\nFinds elements which are on the boundary of the domain. If bdFlag is given, then those indices are added as nodes for a Dirichlet boundary condition (useful for creating cracks and other cutouts of domains).\n\n\nReturns\n\n\nbdNode = Vector of indices for bdNode. Using node[:,bdNode] returns boundary nodes.\n\n\nbdEdge = Vector of indices for boundary edges.\n\n\nisBdNode = Vector of booleans size N which donotes which are on the boundary\n\n\nisBdElem = Vector of booleans size NT which denotes which are on the boundary\n\n\n#\n\n\nDifferentialEquations.setboundary\n \n \nFunction\n.\n\n\nsetboundary(node::AbstractArray,elem::AbstractArray,bdType)\n\n\nsetboundary(femMesh::FEMmesh,bdType)\n\n\nTakes in the femMesh and creates an array bdFlag which denotes the boundary types. 1 stands for Dirichlet, 2 for Neumann, 3 for Robin. \n\n\n#\n\n\nDifferentialEquations.fem_squaremesh\n \n \nFunction\n.\n\n\nfem_squaremesh(square,h)\n\n\nReturns the grid in the iFEM form of the two arrays (node,elem)\n\n\n#\n\n\nDifferentialEquations.notime_squaremesh\n \n \nFunction\n.\n\n\nnotime_squaremesh(square,\u0394x,bdType)\n\n\nComputes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x,\nDirichlet\n)\n\n\n\n\n#\n\n\nDifferentialEquations.parabolic_squaremesh\n \n \nFunction\n.\n\n\nparabolic_squaremesh(square,\u0394x,\u0394t,T,bdType)\n\n\nComputes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,\nDirichlet\n)\n\n\n\n\n\n\nExample Meshes\n\n\n#\n\n\nDifferentialEquations.meshExample_bunny\n \n \nFunction\n.\n\n\nmeshExample_bunny() : Returns a 3D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n \n \nFunction\n.\n\n\nmeshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_lakemesh\n \n \nFunction\n.\n\n\nmeshExample_lakemesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapemesh\n \n \nFunction\n.\n\n\nmeshExample_Lshapemesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n \n \nFunction\n.\n\n\nmeshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_oilpump\n \n \nFunction\n.\n\n\nmeshExample_oilpump() : Returns a 3D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_wavymesh\n \n \nFunction\n.\n\n\nmeshExample_wavymesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n \n \nFunction\n.\n\n\nmeshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#meshes", 
            "text": "", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#mesh-specification", 
            "text": "Finite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:   Row  i  of node is an  (x,y)  (or  (x,y,z) ) pair which specifies the coordinates of the  i th node.  Row  j  of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.   For example, to know the  (x,y)  locations of the vertices of triangle  j , we would see that  node[elem[j,i],:]  are the  (x,y)  locations of the  i th vertex for  i=1,2,3 .  For more information, please see  Programming of Finite Element Methods by Long Chen .", 
            "title": "Mesh Specification"
        }, 
        {
            "location": "/man/mesh/#mesh-type", 
            "text": "#  DifferentialEquations.FEMmesh     Type .  FEMmesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.  bdNode : Vector of indices for the boundary nodes.  freeNode : Vector of indices for the free (non-Dirichlet bound) nodes.  bdEdge : Indices of the edges in totalEdge which are on the boundary.  isBdNode : Boolean which is true for nodes on the boundary.  isBdElem : Boolean which is true for elements on the boundary.  bdFlag : Flag which describes the type of boundary condition. 1=  Dirichlet, 2= Neumann, 3= Robin.  totalEdge : Vector of the edges.  area : Vector which is the area for each element.  Dirichlet : Indices for the nodes on the boundary which have a Dirichlet boundary condition.  Neumann : Indices for the nodes on the boundary which have a Neumann boundary condition.  Robin : Indices for the nodes on the boundary which have a Robin boundary condition.  N::Int : The number of nodes.  NT ::Int: The number of triangles (elements).  \u0394x : The spatial discretization size. If non-uniform, this is the average.  \u0394t : The time discretization size. If adaptive, this is the initial.  T ::Number: The end time.  numIters ::Int: The number of iterations to go from 0 to T using \u0394t.  \u03bc : The CFL \u03bc stability parameter.  \u03bd : The CFL \u03bd stability parameter.  evolutionEq : True for a mesh which has non-trivial time components.   #  DifferentialEquations.SimpleMesh     Type .  SimpleMesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see  Programming of Finite Element Methods by Long Chen .  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.   #  DifferentialEquations.Mesh     Type .  Mesh: An abstract type which holds a (node,elem) pair and other information for a mesh", 
            "title": "Mesh Type"
        }, 
        {
            "location": "/man/mesh/#mesh-generation-functions", 
            "text": "#  DifferentialEquations.findboundary     Function .  findboundary(elem,bdFlag=[])  findboundary(femMesh::FEMmesh,bdFlag=[])  Finds elements which are on the boundary of the domain. If bdFlag is given, then those indices are added as nodes for a Dirichlet boundary condition (useful for creating cracks and other cutouts of domains).  Returns  bdNode = Vector of indices for bdNode. Using node[:,bdNode] returns boundary nodes.  bdEdge = Vector of indices for boundary edges.  isBdNode = Vector of booleans size N which donotes which are on the boundary  isBdElem = Vector of booleans size NT which denotes which are on the boundary  #  DifferentialEquations.setboundary     Function .  setboundary(node::AbstractArray,elem::AbstractArray,bdType)  setboundary(femMesh::FEMmesh,bdType)  Takes in the femMesh and creates an array bdFlag which denotes the boundary types. 1 stands for Dirichlet, 2 for Neumann, 3 for Robin.   #  DifferentialEquations.fem_squaremesh     Function .  fem_squaremesh(square,h)  Returns the grid in the iFEM form of the two arrays (node,elem)  #  DifferentialEquations.notime_squaremesh     Function .  notime_squaremesh(square,\u0394x,bdType)  Computes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.", 
            "title": "Mesh Generation Functions"
        }, 
        {
            "location": "/man/mesh/#example", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x, Dirichlet )  #  DifferentialEquations.parabolic_squaremesh     Function .  parabolic_squaremesh(square,\u0394x,\u0394t,T,bdType)  Computes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example_1", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T, Dirichlet )", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example-meshes", 
            "text": "#  DifferentialEquations.meshExample_bunny     Function .  meshExample_bunny() : Returns a 3D SimpleMesh.  #  DifferentialEquations.meshExample_flowpastcylindermesh     Function .  meshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_lakemesh     Function .  meshExample_lakemesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_Lshapemesh     Function .  meshExample_Lshapemesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_Lshapeunstructure     Function .  meshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_oilpump     Function .  meshExample_oilpump() : Returns a 3D SimpleMesh.  #  DifferentialEquations.meshExample_wavymesh     Function .  meshExample_wavymesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_wavyperturbmesh     Function .  meshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.", 
            "title": "Example Meshes"
        }, 
        {
            "location": "/man/solvers/", 
            "text": "Information on Solvers\n\n\n\n\nFinite Element Method Solvers\n\n\n#\n\n\nDifferentialEquations.fem_solvepoisson\n \n \nFunction\n.\n\n\nFinite Element Poisson Equation Solver\n\n\nfem_solvepoisson(femMesh::FEMmesh,pdeProb::PoissonProblem)\n\n\nTakes in a definition for the heat equation \n-\u0394u = f\n on \nfemMesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic Poisson equation \n-\u0394u = f + \u03c3dW\n.\n\n\nKeyword Arguments\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\nDirect\n = Solves \nAx=b\n using ``\n\n\nCG\n = Conjugate-Gradient. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.\n\n\nGMRES\n = GMRES. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is not positive definite.\n\n\nsaveSteps\n = If \nfullSave=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\n\n\n#\n\n\nDifferentialEquations.fem_solveheat\n \n \nFunction\n.\n\n\nFinite Element Heat Equation Solver\n\n\nfem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation \nu_t = \u0394u + f\n on \nfemMesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic heat equation \nu_t = \u0394u + f + \u03c3dW_t\n.\n\n\nKeyword Arguments\n\n\n\n\nalg\n = Solution algorithm. Default is Euler. The choices are:\n\n\nLinear     * Euler (Explicit)     * Implicit Euler (Implicit)     * Crank-Nicholson (Implicit)\n\n\nNonlinear     * Euler (Explicit)     * Implicit Euler (Nonlinear Solve)     * Crank-Nicholson (Nonlinear Solve)     * Semi-Implicit Euler (Implicit)     * Semi-Implicit Crank-Nicholson (Implicit)\n\n\n\n\nExplicit algorithms only require solving matrix multiplications \nAu\n. Implicit algorithms require solving the linear equation \nAx=b\n where \nx\n is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\nDirect\n = Solves using `` (no factorization). Not recommended.\n\n\nCholesky\n = Cholsky decomposition. Only stable of \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.     This means that this works best when \u0394t is small. When applicable, this is the fastest.\n\n\nLU\n = LU-Decomposition. A good mix between fast and stable.\n\n\nQR\n = QR-Decomposition. Less numerical roundoff error than \nLU\n, but slightly slower.\n\n\nSVD\n = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.\n\n\nCG\n = Conjugate-Gradient. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.\n\n\nGMRES\n = GMRES. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is not positive definite.\n\n\nfullSave\n = Makes the algorithm save the output at every \nsaveSteps\n timesteps. By default fullSave is false.\n\n\nsaveSteps\n = If \nfullSave=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.", 
            "title": "Information on Solvers"
        }, 
        {
            "location": "/man/solvers/#information-on-solvers", 
            "text": "", 
            "title": "Information on Solvers"
        }, 
        {
            "location": "/man/solvers/#finite-element-method-solvers", 
            "text": "#  DifferentialEquations.fem_solvepoisson     Function .  Finite Element Poisson Equation Solver  fem_solvepoisson(femMesh::FEMmesh,pdeProb::PoissonProblem)  Takes in a definition for the heat equation  -\u0394u = f  on  femMesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic Poisson equation  -\u0394u = f + \u03c3dW .  Keyword Arguments   solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:  Direct  = Solves  Ax=b  using ``  CG  = Conjugate-Gradient. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.  GMRES  = GMRES. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is not positive definite.  saveSteps  = If  fullSave=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.   #  DifferentialEquations.fem_solveheat     Function .  Finite Element Heat Equation Solver  fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation  u_t = \u0394u + f  on  femMesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic heat equation  u_t = \u0394u + f + \u03c3dW_t .  Keyword Arguments   alg  = Solution algorithm. Default is Euler. The choices are:  Linear     * Euler (Explicit)     * Implicit Euler (Implicit)     * Crank-Nicholson (Implicit)  Nonlinear     * Euler (Explicit)     * Implicit Euler (Nonlinear Solve)     * Crank-Nicholson (Nonlinear Solve)     * Semi-Implicit Euler (Implicit)     * Semi-Implicit Crank-Nicholson (Implicit)   Explicit algorithms only require solving matrix multiplications  Au . Implicit algorithms require solving the linear equation  Ax=b  where  x  is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).   solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:  Direct  = Solves using `` (no factorization). Not recommended.  Cholesky  = Cholsky decomposition. Only stable of  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.     This means that this works best when \u0394t is small. When applicable, this is the fastest.  LU  = LU-Decomposition. A good mix between fast and stable.  QR  = QR-Decomposition. Less numerical roundoff error than  LU , but slightly slower.  SVD  = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.  CG  = Conjugate-Gradient. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.  GMRES  = GMRES. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is not positive definite.  fullSave  = Makes the algorithm save the output at every  saveSteps  timesteps. By default fullSave is false.  saveSteps  = If  fullSave=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.", 
            "title": "Finite Element Method Solvers"
        }, 
        {
            "location": "/man/solution/", 
            "text": "The Solution Type\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.FEMSolution\n \n \nType\n.\n\n\nFEMSolution\n\n\nHolds the data for the solution to a finite element problem.\n\n\nFields\n\n\n\n\nfemMesh::FEMmesh\n: The finite element mesh the problem was solved on.\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueKnown::Bool\n: Boolean flag for if the true solution is given.\n\n\nuTrue::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nl2Err::NumberOrVoid\n: The L2 error between u and uTrue.\n\n\nh1Err::NumberOrVoid\n: The H1 error between u and uTrue.\n\n\nmaxErr::NumberOrVoid\n: The nodal maximum error between u and uTrue.\n\n\nnodeErr2::NumberOrVoid\n: The nodal l2 error between y abd uTrue.\n\n\nappxTrue::Bool\n: Boolean flag for if uTrue was an approximation.\n\n\nuFull\n::AbstractArrayOrVoid\n: u over time. Only saved if\nfullSave=true` is specified in the solver.\n\n\ntFull::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nfullSave=true\n is specified in the solver.\n\n\nfullSave::Bool\n: True if solver saved the extra timepoints.\n\n\n\n\n#\n\n\nDifferentialEquations.appxTrue!\n \n \nFunction\n.\n\n\nappxTrue!(res,res2)\n\n\nAdds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution\n\n\n#\n\n\nDifferentialEquations.PdeSolution\n \n \nType\n.\n\n\nPdeSolution: Wrapper for the objects obtained from a PdeSolver", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#the-solution-type", 
            "text": "", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#related-functions", 
            "text": "#  DifferentialEquations.FEMSolution     Type .  FEMSolution  Holds the data for the solution to a finite element problem.  Fields   femMesh::FEMmesh : The finite element mesh the problem was solved on.  u::Array{Float64} : The solution (at the final timepoint)  trueKnown::Bool : Boolean flag for if the true solution is given.  uTrue::AbstractArrayOrVoid : The true solution at the final timepoint.  l2Err::NumberOrVoid : The L2 error between u and uTrue.  h1Err::NumberOrVoid : The H1 error between u and uTrue.  maxErr::NumberOrVoid : The nodal maximum error between u and uTrue.  nodeErr2::NumberOrVoid : The nodal l2 error between y abd uTrue.  appxTrue::Bool : Boolean flag for if uTrue was an approximation.  uFull ::AbstractArrayOrVoid : u over time. Only saved if fullSave=true` is specified in the solver.  tFull::AbstractArrayOrVoid : All the t's in the solution. Only saved if  fullSave=true  is specified in the solver.  fullSave::Bool : True if solver saved the extra timepoints.   #  DifferentialEquations.appxTrue!     Function .  appxTrue!(res,res2)  Adds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution  #  DifferentialEquations.PdeSolution     Type .  PdeSolution: Wrapper for the objects obtained from a PdeSolver", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/plot/", 
            "text": "Plot Functions\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.solplot_appxvstrue\n \n \nFunction\n.\n\n\nsolplot_appxvstrue(res::FEMSolution)\n\n\nPlots the approximate solution and the true solution.\n\n\nKeyword Arguments\n\n\n\n\nsavefile\n: Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.\n\n\ntitle\n: The title at the top of the plot. Default is \"PDE Solution\".\n\n\nappxTitle\n: The title above the approximate solution. Default is \"Approximated Solution\".\n\n\ntrueTitle\n: The title above the true solution. Default is \"True Solution\".\n\n\ncmap\n: Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").\n\n\n\n\n#\n\n\nDifferentialEquations.solplot_animation\n \n \nFunction\n.\n\n\nsolplot_animation(res::FEMSolution)\n\n\nPlots an animation of the solution. Requires \nfullSave=true\n was enabled in the solver.\n\n\nKeyword Arguments\n\n\n\n\nzlim\n: The limits on the z-axis in the simulation. Default nothing.\n\n\ncbar\n: Boolean flag which turns on/off the color bar. Default true.\n\n\n\n\n#\n\n\nDifferentialEquations.convplot\n \n \nFunction\n.\n\n\nconvplot(measure,err)\n\n\nMakes a convergence plot of err vs measure in loglog scale.\n\n\nKeyword Arguments\n\n\n\n\nErrStr\n: The y-axis label. Default is \"Error\".\n\n\nmeasureStr\n: The x-axis label. Default is \"Measure\".\n\n\ntitleStr\n: The title. Default is \":ErrStr vs :measureStr Convergence Plot\".\n\n\n\n\n#\n\n\nDifferentialEquations.solplot\n \n \nFunction\n.\n\n\nsolplot(res::FEMSolution)\n\n\nPlots the approximate solution and, if available, the true solution.\n\n\nKeyword Arguments\n\n\n\n\nsavefile\n: Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.\n\n\ntitle\n: The title at the top of the plot. Default is \"PDE Solution\".\n\n\nappxTitle\n: The title above the approximate solution. Default is \"Approximated Solution\".\n\n\ntrueTitle\n: The title above the true solution. Default is \"True Solution\".\n\n\ncmap\n: Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").\n\n\n\n\n#\n\n\nDifferentialEquations.solplot_appx\n \n \nFunction\n.\n\n\nsolplot_appx(res::FEMSolution)\n\n\nPlots the approximate solution.\n\n\nKeyword Arguments\n\n\n\n\nsavefile\n: Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.\n\n\ntitle\n: The title at the top of the plot. Default is \"PDE Solution\".\n\n\ncmap\n: Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").\n\n\n\n\n#\n\n\nDifferentialEquations.showmesh\n \n \nFunction\n.\n\n\nshowmesh(femMesh::FEMmesh)\n\n\nShows the mesh which is defined by the (node,elem) structure.\n\n\nKeyword Arguments\n\n\n\n\ncmap\n: Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#plot-functions", 
            "text": "", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#related-functions", 
            "text": "#  DifferentialEquations.solplot_appxvstrue     Function .  solplot_appxvstrue(res::FEMSolution)  Plots the approximate solution and the true solution.  Keyword Arguments   savefile : Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.  title : The title at the top of the plot. Default is \"PDE Solution\".  appxTitle : The title above the approximate solution. Default is \"Approximated Solution\".  trueTitle : The title above the true solution. Default is \"True Solution\".  cmap : Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").   #  DifferentialEquations.solplot_animation     Function .  solplot_animation(res::FEMSolution)  Plots an animation of the solution. Requires  fullSave=true  was enabled in the solver.  Keyword Arguments   zlim : The limits on the z-axis in the simulation. Default nothing.  cbar : Boolean flag which turns on/off the color bar. Default true.   #  DifferentialEquations.convplot     Function .  convplot(measure,err)  Makes a convergence plot of err vs measure in loglog scale.  Keyword Arguments   ErrStr : The y-axis label. Default is \"Error\".  measureStr : The x-axis label. Default is \"Measure\".  titleStr : The title. Default is \":ErrStr vs :measureStr Convergence Plot\".   #  DifferentialEquations.solplot     Function .  solplot(res::FEMSolution)  Plots the approximate solution and, if available, the true solution.  Keyword Arguments   savefile : Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.  title : The title at the top of the plot. Default is \"PDE Solution\".  appxTitle : The title above the approximate solution. Default is \"Approximated Solution\".  trueTitle : The title above the true solution. Default is \"True Solution\".  cmap : Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").   #  DifferentialEquations.solplot_appx     Function .  solplot_appx(res::FEMSolution)  Plots the approximate solution.  Keyword Arguments   savefile : Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.  title : The title at the top of the plot. Default is \"PDE Solution\".  cmap : Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").   #  DifferentialEquations.showmesh     Function .  showmesh(femMesh::FEMmesh)  Shows the mesh which is defined by the (node,elem) structure.  Keyword Arguments   cmap : Specifies the color map in the plot. Default is PyPlot.get_cmap(\"winter\").", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/convergence/", 
            "text": "Convergence Simulations\n\n\nThe convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.\n\n\n\n\nThe ConvergenceSimulation Type\n\n\n#\n\n\nDifferentialEquations.ConvergenceSimulation\n \n \nType\n.\n\n\nConvergenceSimulation\n\n\nA type which holds the data from a convergence simulation.\n\n\nFields\n\n\n\n\nsolutions::Array{PdeSolution}\n: Holds all the PdeSolutions.\n\n\nh1Errors\n: Vector of the H1 errors.\n\n\nl2Errors\n: Vector of the L2 errors.\n\n\nmaxErrors\n: Vector of the nodal maximum errors.\n\n\nnode2Errors\n: Vector of the nodal l2 errors.\n\n\nN\n: The number of simulations.\n\n\n\u0394ts\n: The \u0394t's in the simulations.\n\n\n\u0394xs\n: The \u0394x's in the simulations.\n\n\n\u03bcs\n: The CFL \u03bc's in the simulations.\n\n\n\u03bds\n: The CFL \u03bd's in the simulations.\n\n\nConvEst_h1\n: The H1 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1)\n\n\nConvEst_l2\n: The L2 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2)\n\n\nConvEst_max\n: The nodal maximum error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max)\n\n\nConvEst_node2\n: The nodal l2 error order of convergence estimate for the convergence simulation. Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)\n\n\n\n\n\n\nRelated Functions\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation\n\n\n#\n\n\nDifferentialEquations.conv_ests\n \n \nFunction\n.\n\n\nconv_ests(error::Vector{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\n\n\nPlot Functions\n\n\n#\n\n\nDifferentialEquations.convplot_full\u0394t\n \n \nFunction\n.\n\n\nconvplot_full\u0394t(simres::ConvergenceSimulation)\n\n\nPlots a grid which shows the H1, L2, nodal maximum, and nodal l2 error convergence over changes of \u0394t.\n\n\nKeyword Arguments\n\n\n\n\nsavefile\n: Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.\n\n\n\n\n#\n\n\nDifferentialEquations.convplot_full\u0394x\n \n \nFunction\n.\n\n\nconvplot_full\u0394x(simres::ConvergenceSimulation)\n\n\nPlots a grid which shows the H1, L2, nodal maximum, and nodal l2 error convergence over changes of \u0394x.\n\n\nKeyword Arguments\n\n\n\n\nsavefile\n: Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.\n\n\n\n\n#\n\n\nDifferentialEquations.convplot_node2vs\u0394t\n \n \nFunction\n.\n\n\nconvplot_node2vs\u0394t(simres::ConvergenceSimulation)\n\n\nShows the nodal l2 error convergence over changes of \u0394t.\n\n\n#\n\n\nDifferentialEquations.convplot_maxvs\u0394x\n \n \nFunction\n.\n\n\nconvplot_maxvs\u0394x(simres::ConvergenceSimulation)\n\n\nShows the nodal maximum error convergence over changes of \u0394x.\n\n\n#\n\n\nDifferentialEquations.convplot_l2vs\u0394t\n \n \nFunction\n.\n\n\nconvplot_l2vs\u0394t(simres::ConvergenceSimulation)\n\n\nShows the L2 error convergence over changes of \u0394t.\n\n\n#\n\n\nDifferentialEquations.convplot_h1vs\u0394t\n \n \nFunction\n.\n\n\nconvplot_h1vs\u0394t(simres::ConvergenceSimulation)\n\n\nShows the H1 error convergence over changes of \u0394t.\n\n\n#\n\n\nDifferentialEquations.convplot_l2vs\u0394x\n \n \nFunction\n.\n\n\nconvplot_l2vs\u0394x(simres::ConvergenceSimulation)\n\n\nShows the nodal l2 error convergence over changes of \u0394x.\n\n\n#\n\n\nDifferentialEquations.convplot_h1vs\u0394x\n \n \nFunction\n.\n\n\nconvplot_h1vs\u0394x(simres::ConvergenceSimulation)\n\n\nShows the H1 error convergence over changes of \u0394x.\n\n\n#\n\n\nDifferentialEquations.convplot_node2vs\u0394x\n \n \nFunction\n.\n\n\nconvplot_node2vs\u0394x(simres::ConvergenceSimulation)\n\n\nShows the nodal l2 error convergence over changes of \u0394x.\n\n\n#\n\n\nDifferentialEquations.convplot_maxvs\u0394t\n \n \nFunction\n.\n\n\nconvplot_maxvs\u0394t(simres::ConvergenceSimulation)\n\n\nShows the nodal maximum error convergence over changes of \u0394t.", 
            "title": "Convergence Simuations"
        }, 
        {
            "location": "/man/convergence/#convergence-simulations", 
            "text": "The convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.", 
            "title": "Convergence Simulations"
        }, 
        {
            "location": "/man/convergence/#the-convergencesimulation-type", 
            "text": "#  DifferentialEquations.ConvergenceSimulation     Type .  ConvergenceSimulation  A type which holds the data from a convergence simulation.  Fields   solutions::Array{PdeSolution} : Holds all the PdeSolutions.  h1Errors : Vector of the H1 errors.  l2Errors : Vector of the L2 errors.  maxErrors : Vector of the nodal maximum errors.  node2Errors : Vector of the nodal l2 errors.  N : The number of simulations.  \u0394ts : The \u0394t's in the simulations.  \u0394xs : The \u0394x's in the simulations.  \u03bcs : The CFL \u03bc's in the simulations.  \u03bds : The CFL \u03bd's in the simulations.  ConvEst_h1 : The H1 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1)  ConvEst_l2 : The L2 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2)  ConvEst_max : The nodal maximum error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max)  ConvEst_node2 : The nodal l2 error order of convergence estimate for the convergence simulation. Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)", 
            "title": "The ConvergenceSimulation Type"
        }, 
        {
            "location": "/man/convergence/#related-functions", 
            "text": "#  Base.length     Method .  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation  #  DifferentialEquations.conv_ests     Function .  conv_ests(error::Vector{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/convergence/#plot-functions", 
            "text": "#  DifferentialEquations.convplot_full\u0394t     Function .  convplot_full\u0394t(simres::ConvergenceSimulation)  Plots a grid which shows the H1, L2, nodal maximum, and nodal l2 error convergence over changes of \u0394t.  Keyword Arguments   savefile : Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.   #  DifferentialEquations.convplot_full\u0394x     Function .  convplot_full\u0394x(simres::ConvergenceSimulation)  Plots a grid which shows the H1, L2, nodal maximum, and nodal l2 error convergence over changes of \u0394x.  Keyword Arguments   savefile : Designates a file to save the plot in. Save type is defined by the chosen extension. Default is \"\" which implies no saving.   #  DifferentialEquations.convplot_node2vs\u0394t     Function .  convplot_node2vs\u0394t(simres::ConvergenceSimulation)  Shows the nodal l2 error convergence over changes of \u0394t.  #  DifferentialEquations.convplot_maxvs\u0394x     Function .  convplot_maxvs\u0394x(simres::ConvergenceSimulation)  Shows the nodal maximum error convergence over changes of \u0394x.  #  DifferentialEquations.convplot_l2vs\u0394t     Function .  convplot_l2vs\u0394t(simres::ConvergenceSimulation)  Shows the L2 error convergence over changes of \u0394t.  #  DifferentialEquations.convplot_h1vs\u0394t     Function .  convplot_h1vs\u0394t(simres::ConvergenceSimulation)  Shows the H1 error convergence over changes of \u0394t.  #  DifferentialEquations.convplot_l2vs\u0394x     Function .  convplot_l2vs\u0394x(simres::ConvergenceSimulation)  Shows the nodal l2 error convergence over changes of \u0394x.  #  DifferentialEquations.convplot_h1vs\u0394x     Function .  convplot_h1vs\u0394x(simres::ConvergenceSimulation)  Shows the H1 error convergence over changes of \u0394x.  #  DifferentialEquations.convplot_node2vs\u0394x     Function .  convplot_node2vs\u0394x(simres::ConvergenceSimulation)  Shows the nodal l2 error convergence over changes of \u0394x.  #  DifferentialEquations.convplot_maxvs\u0394t     Function .  convplot_maxvs\u0394t(simres::ConvergenceSimulation)  Shows the nodal maximum error convergence over changes of \u0394t.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/internals/femTools/", 
            "text": "Internal Finite Element Tools\n\n\n\n\nGeneral\n\n\n#\n\n\nDifferentialEquations\n \n \nModule\n.\n\n\nDifferentialEquations\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see \nODE.jl\n\n\nThis package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.\n\n\n\n\nMesh Tools\n\n\n#\n\n\nDifferentialEquations.meshgrid\n \n \nFunction\n.\n\n\nmeshgrid(vx,vy,vz)\n\n\nComputes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.\n\n\nmeshgrid(vx,vy)\n\n\nComputes an (x,y)-grid from the vectors (vx,vy). For more information, see the MATLAB documentation.\n\n\nmeshgrid(vx)\n\n\nComputes an (x,y)-grid from the vectors (vx,vx). For more information, see the MATLAB documentation.\n\n\n#\n\n\nDifferentialEquations.CFL\u03bd\n \n \nFunction\n.\n\n\nCFL\u03bd(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bd= \u0394t/\u0394x\n\n\n#\n\n\nDifferentialEquations.CFL\u03bc\n \n \nFunction\n.\n\n\nCFL\u03bc(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)\n\n\n\n\nSolver Tools\n\n\n#\n\n\nDifferentialEquations.\u2207basis\n \n \nFunction\n.\n\n\n\u2207basis(node,elem)\n\n\nReturns the \u2207u of the barycentric basis elements.\n\n\n#\n\n\nDifferentialEquations.quadfbasis\n \n \nFunction\n.\n\n\nquadfbasis(f,gD,gN,A,u,node,elem,area,bdNode,mid,N,Dirichlet,Neumann,isLinear;gNquad\ud835\udcaa=2)\n\n\nPerforms the order 2 quadrature to calculate the vector from the term \nf,v\n.\n\n\n#\n\n\nDifferentialEquations.quadpts\n \n \nFunction\n.\n\n\nquadpts(\ud835\udcaa)\n\n\nReturns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.\n\n\nReference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.\n\n\n#\n\n\nDifferentialEquations.quadpts1\n \n \nFunction\n.\n\n\nquadpts1(\ud835\udcaa)\n\n\nReferences: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/\n\n\n#\n\n\nDifferentialEquations.accumarray\n \n \nFunction\n.\n\n\naccumarray(subs, val, sz=(maximum(subs),))\n\n\nSee MATLAB's documentation for more details.\n\n\n#\n\n\nDifferentialEquations.assemblematrix\n \n \nFunction\n.\n\n\nassemblematrix(node,elem;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nassemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\n#\n\n\nDifferentialEquations.\u2207u\n \n \nFunction\n.\n\n\n\u2207u(node,elem,u,D\u03bb=[])\n\n\nEstimates \u2207u of u on the mesh (node,elem)\n\n\n\n\nError Tools\n\n\n#\n\n\nDifferentialEquations.getH1error\n \n \nFunction\n.\n\n\nfunction getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])\n\n\ngetH1error(femMesh::FEMmesh,Du,u)\n\n\nEstimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.\n\n\n#\n\n\nDifferentialEquations.getL2error\n \n \nFunction\n.\n\n\ngetL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])\n\n\ngetL2error(femMesh::FEMmesh,sol,u)\n\n\nEstimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/femTools/#internal-finite-element-tools", 
            "text": "", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/femTools/#general", 
            "text": "#  DifferentialEquations     Module .", 
            "title": "General"
        }, 
        {
            "location": "/internals/femTools/#differentialequations", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see  ODE.jl  This package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.", 
            "title": "DifferentialEquations"
        }, 
        {
            "location": "/internals/femTools/#mesh-tools", 
            "text": "#  DifferentialEquations.meshgrid     Function .  meshgrid(vx,vy,vz)  Computes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.  meshgrid(vx,vy)  Computes an (x,y)-grid from the vectors (vx,vy). For more information, see the MATLAB documentation.  meshgrid(vx)  Computes an (x,y)-grid from the vectors (vx,vx). For more information, see the MATLAB documentation.  #  DifferentialEquations.CFL\u03bd     Function .  CFL\u03bd(\u0394t,\u0394x)  Computes the CFL-condition \u03bd= \u0394t/\u0394x  #  DifferentialEquations.CFL\u03bc     Function .  CFL\u03bc(\u0394t,\u0394x)  Computes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)", 
            "title": "Mesh Tools"
        }, 
        {
            "location": "/internals/femTools/#solver-tools", 
            "text": "#  DifferentialEquations.\u2207basis     Function .  \u2207basis(node,elem)  Returns the \u2207u of the barycentric basis elements.  #  DifferentialEquations.quadfbasis     Function .  quadfbasis(f,gD,gN,A,u,node,elem,area,bdNode,mid,N,Dirichlet,Neumann,isLinear;gNquad\ud835\udcaa=2)  Performs the order 2 quadrature to calculate the vector from the term  f,v .  #  DifferentialEquations.quadpts     Function .  quadpts(\ud835\udcaa)  Returns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.  Reference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.  #  DifferentialEquations.quadpts1     Function .  quadpts1(\ud835\udcaa)  References: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/  #  DifferentialEquations.accumarray     Function .  accumarray(subs, val, sz=(maximum(subs),))  See MATLAB's documentation for more details.  #  DifferentialEquations.assemblematrix     Function .  assemblematrix(node,elem;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  assemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  #  DifferentialEquations.\u2207u     Function .  \u2207u(node,elem,u,D\u03bb=[])  Estimates \u2207u of u on the mesh (node,elem)", 
            "title": "Solver Tools"
        }, 
        {
            "location": "/internals/femTools/#error-tools", 
            "text": "#  DifferentialEquations.getH1error     Function .  function getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])  getH1error(femMesh::FEMmesh,Du,u)  Estimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.  #  DifferentialEquations.getL2error     Function .  getL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])  getL2error(femMesh::FEMmesh,sol,u)  Estimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.", 
            "title": "Error Tools"
        }, 
        {
            "location": "/internals/extras/", 
            "text": "Extra Functions\n\n\n#\n\n\nDifferentialEquations.modulechildren\n \n \nFunction\n.\n\n\nmodulechildren(m::Module)\n\n\nReturns the modules in m\n\n\n#\n\n\nDifferentialEquations.checkIfLoaded\n \n \nFunction\n.\n\n\ncheckIfLoaded(pkg::AbstractString)\n\n\nReturns true if module \"pkg\" is defined in Main, otherwise false.\n\n\n#\n\n\nDifferentialEquations.getNoise\n \n \nFunction\n.\n\n\ngetNoise(N,node,elem;noiseType=\"White\")\n\n\nReturns a random vector corresponding to the noise type which was chosen.\n\n\n#\n\n\nDifferentialEquations.numparameters\n \n \nFunction\n.\n\n\nnumparameters(f)\n\n\nReturns the number of parameters of \nf\n for the method which has the most parameters.", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#extra-functions", 
            "text": "#  DifferentialEquations.modulechildren     Function .  modulechildren(m::Module)  Returns the modules in m  #  DifferentialEquations.checkIfLoaded     Function .  checkIfLoaded(pkg::AbstractString)  Returns true if module \"pkg\" is defined in Main, otherwise false.  #  DifferentialEquations.getNoise     Function .  getNoise(N,node,elem;noiseType=\"White\")  Returns a random vector corresponding to the noise type which was chosen.  #  DifferentialEquations.numparameters     Function .  numparameters(f)  Returns the number of parameters of  f  for the method which has the most parameters.", 
            "title": "Extra Functions"
        }
    ]
}