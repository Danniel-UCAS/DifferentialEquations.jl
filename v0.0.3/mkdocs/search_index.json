{
    "docs": [
        {
            "location": "/", 
            "text": "DifferentialEquations.jl Documentation\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations.\n\n\nAll of the algorithms are thoroughly tested to ensure accuracy. Convergence tests  are included in the \ntest/\n folder if you're interested. The algorithms were also tested to show correctness with nontrivial behavior such as Turing morphogenesis. If you find any equation where there seems to be an error, please open an issue.\n\n\nThis package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes. Since this package is designed for long computations, one of the features of this package is the existence of tools for inspecting a long calculation. These include optional printing and, if the user is using Juno, a progress meter (with time estimates once implemented on Juno's end).\n\n\nIf you have any questions, or just want to chat about solvers/using the package, please feel free to message me in the Gitter channel. For bug reports, feature requests, etc., please submit an issue.\n\n\n\n\nNote on Compatibility\n\n\nThe v0.0.3 release is the last release targetting Julia v0.4. Future development will be targeting Julia v0.5 and does not guerentee backwards compatibility with v0.4. That said, most of the code should work. The only breaking change may be within the dependency ChunkedArrays which will require a very different method of parallelism in future versions, and thus one should make sure to use the tag for v0.4 in ChunkedArrays.\n\n\n\n\nUsing the Package\n\n\nTo install the package, use the following command inside the Julia REPL:\n\n\nPkg.add(\nDifferentialEquations\n)\n\n\n\n\nFor all of the latest features, switch to the master branch via:\n\n\nPkg.checkout(\nDifferentialEquations\n)\n\n\n\n\nTo load the package, use the command:\n\n\nusing DifferentialEquations\n\n\n\n\nTo understand the package in more detail, check out the following tutorials. Example codes for the latest features can be found in \ntest/\n. Note that for many of the examples in the test folder, you may wish to run them at lower \u0394x or \u0394t. These values were taken to be large in order make unit tests run faster!\n\n\nFor the most up to date on using the package information, please contact me \nvia the repository Gitter\n or \nread the latest documentation\n\n\n\n\nTutorials\n\n\nThe following tutorials will introduce you to the functionality of DifferentialEquations.jl\n\n\n\n\nOrdinary Differential Equation (ODE) Example\n\n\nStochastic Differential Equation (SDE) Example\n\n\nPoisson Equation Finite Element Method Example\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\n\n\n\n\nManual\n\n\n\n\nOverview of DifferentialEquations.jl Usage\n\n\nDefining an ODE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nDefining a SDE Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nDefining a FEM Problem\n\n\nPoisson Equation Problem\n\n\nHeat Equation Problem\n\n\nExample Problems\n\n\nRelated Functions\n\n\n\n\n\n\nDefining a Stokes Problem\n\n\nProblem Type\n\n\nExample Problems\n\n\n\n\n\n\nMeshes\n\n\nMesh Specification\n\n\nMesh Type\n\n\nMesh Generation Functions\n\n\nExample Meshes\n\n\nPlot Functions\n\n\n\n\n\n\nInformation on Solvers\n\n\nOrdinary Differential Equation Solvers\n\n\nStochastic Differential Equation Solvers\n\n\nFinite Difference Method Solvers\n\n\nFinite Element Method Solvers\n\n\n\n\n\n\nThe Solution Type\n\n\nSolution Types\n\n\nRelated Functions\n\n\n\n\n\n\nPlot Functions\n\n\nStandard Plots\n\n\nExtra Plot Functions\n\n\n\n\n\n\nConvergence Simulations\n\n\nThe ConvergenceSimulation Type\n\n\nPlot Functions\n\n\nRelated Functions\n\n\n\n\n\n\n\n\n\n\nInternal Documentation\n\n\n\n\nInternal Finite Element Tools\n\n\nGeneral\n\n\nMesh Tools\n\n\nSolver Tools\n\n\nError Tools\n\n\n\n\n\n\nExtra Functions\n\n\nMaking Build Work\n\n\n\n\n\n\nSolver Helpers\n\n\nODE\n\n\nStationary Stokes\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDifferentialEquations\n\n\nDifferentialEquations.DEFAULT_TABLEAU\n\n\nDifferentialEquations.ConvergenceSimulation\n\n\nDifferentialEquations.DEProblem\n\n\nDifferentialEquations.DESolution\n\n\nDifferentialEquations.ExplicitRK\n\n\nDifferentialEquations.FEMSolution\n\n\nDifferentialEquations.FEMmesh\n\n\nDifferentialEquations.HeatProblem\n\n\nDifferentialEquations.Mesh\n\n\nDifferentialEquations.ODEProblem\n\n\nDifferentialEquations.ODESolution\n\n\nDifferentialEquations.PoissonProblem\n\n\nDifferentialEquations.RosslerSRA\n\n\nDifferentialEquations.RosslerSRI\n\n\nDifferentialEquations.SDEProblem\n\n\nDifferentialEquations.SDESolution\n\n\nDifferentialEquations.SimpleMesh\n\n\nDifferentialEquations.StokesProblem\n\n\nDifferentialEquations.StokesSolution\n\n\nBase.length\n\n\nBase.size\n\n\nDifferentialEquations.CFL\u03bc\n\n\nDifferentialEquations.CFL\u03bd\n\n\nDifferentialEquations.FEMSolutionTS\n\n\nDifferentialEquations.GSu!\n\n\nDifferentialEquations.GSv!\n\n\nDifferentialEquations.GS\u03b4q!\n\n\nDifferentialEquations.accumarray\n\n\nDifferentialEquations.additiveSDEExample\n\n\nDifferentialEquations.animate\n\n\nDifferentialEquations.appxTrue!\n\n\nDifferentialEquations.assemblematrix\n\n\nDifferentialEquations.calc_rp!\n\n\nDifferentialEquations.calc\ud835\udcaaestimates\n\n\nDifferentialEquations.checkSRAOrder\n\n\nDifferentialEquations.checkSRIOrder\n\n\nDifferentialEquations.constructBogakiShampine\n\n\nDifferentialEquations.constructCashKarp\n\n\nDifferentialEquations.constructDormandPrince\n\n\nDifferentialEquations.constructHuen\n\n\nDifferentialEquations.constructRKF\n\n\nDifferentialEquations.constructRKF8\n\n\nDifferentialEquations.constructRalston\n\n\nDifferentialEquations.constructSRA1\n\n\nDifferentialEquations.constructSRIW1\n\n\nDifferentialEquations.conv_ests\n\n\nDifferentialEquations.cubicSDEExample\n\n\nDifferentialEquations.dirichletzeroStokesExample\n\n\nDifferentialEquations.fem_squaremesh\n\n\nDifferentialEquations.findboundary\n\n\nDifferentialEquations.getH1error\n\n\nDifferentialEquations.getL2error\n\n\nDifferentialEquations.getNoise\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n\n\nDifferentialEquations.heatProblemExample_birthdeathinteractingsystem\n\n\nDifferentialEquations.heatProblemExample_birthdeathsystem\n\n\nDifferentialEquations.heatProblemExample_diffuse\n\n\nDifferentialEquations.heatProblemExample_diffusionconstants\n\n\nDifferentialEquations.heatProblemExample_gierermeinhardt\n\n\nDifferentialEquations.heatProblemExample_grayscott\n\n\nDifferentialEquations.heatProblemExample_moving\n\n\nDifferentialEquations.heatProblemExample_pure\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n\n\nDifferentialEquations.homogeneousStokesExample\n\n\nDifferentialEquations.linearODEExample\n\n\nDifferentialEquations.linearSDEExample\n\n\nDifferentialEquations.meshExample_Lshapemesh\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n\n\nDifferentialEquations.meshExample_bunny\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n\n\nDifferentialEquations.meshExample_lakemesh\n\n\nDifferentialEquations.meshExample_oilpump\n\n\nDifferentialEquations.meshExample_wavymesh\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n\n\nDifferentialEquations.meshgrid\n\n\nDifferentialEquations.monteCarloSim\n\n\nDifferentialEquations.multiDimAdditiveSDEExample\n\n\nDifferentialEquations.notime_squaremesh\n\n\nDifferentialEquations.numparameters\n\n\nDifferentialEquations.parabolic_squaremesh\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n\n\nDifferentialEquations.poissonProblemExample_birthdeathinteractingsystem\n\n\nDifferentialEquations.poissonProblemExample_birthdeathsystem\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n\n\nDifferentialEquations.poissonProblemExample_wave\n\n\nDifferentialEquations.quadfbasis\n\n\nDifferentialEquations.quadpts\n\n\nDifferentialEquations.quadpts1\n\n\nDifferentialEquations.setboundary\n\n\nDifferentialEquations.solve\n\n\nDifferentialEquations.stokes_prolongation\n\n\nDifferentialEquations.stokes_restriction\n\n\nDifferentialEquations.testConvergence\n\n\nDifferentialEquations.twoDimlinearODEExample\n\n\nDifferentialEquations.twoDimlinearSDEExample\n\n\nDifferentialEquations.update_p!\n\n\nDifferentialEquations.update_u!\n\n\nDifferentialEquations.update_v!\n\n\nDifferentialEquations.uzawa_p!\n\n\nDifferentialEquations.waveSDEExample\n\n\nDifferentialEquations.\u2207basis\n\n\nDifferentialEquations.\u2207u", 
            "title": "Introduction"
        }, 
        {
            "location": "/#differentialequationsjl-documentation", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include ordinary differential equations (ODEs), stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations.  All of the algorithms are thoroughly tested to ensure accuracy. Convergence tests  are included in the  test/  folder if you're interested. The algorithms were also tested to show correctness with nontrivial behavior such as Turing morphogenesis. If you find any equation where there seems to be an error, please open an issue.  This package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes. Since this package is designed for long computations, one of the features of this package is the existence of tools for inspecting a long calculation. These include optional printing and, if the user is using Juno, a progress meter (with time estimates once implemented on Juno's end).  If you have any questions, or just want to chat about solvers/using the package, please feel free to message me in the Gitter channel. For bug reports, feature requests, etc., please submit an issue.", 
            "title": "DifferentialEquations.jl Documentation"
        }, 
        {
            "location": "/#note-on-compatibility", 
            "text": "The v0.0.3 release is the last release targetting Julia v0.4. Future development will be targeting Julia v0.5 and does not guerentee backwards compatibility with v0.4. That said, most of the code should work. The only breaking change may be within the dependency ChunkedArrays which will require a very different method of parallelism in future versions, and thus one should make sure to use the tag for v0.4 in ChunkedArrays.", 
            "title": "Note on Compatibility"
        }, 
        {
            "location": "/#using-the-package", 
            "text": "To install the package, use the following command inside the Julia REPL:  Pkg.add( DifferentialEquations )  For all of the latest features, switch to the master branch via:  Pkg.checkout( DifferentialEquations )  To load the package, use the command:  using DifferentialEquations  To understand the package in more detail, check out the following tutorials. Example codes for the latest features can be found in  test/ . Note that for many of the examples in the test folder, you may wish to run them at lower \u0394x or \u0394t. These values were taken to be large in order make unit tests run faster!  For the most up to date on using the package information, please contact me  via the repository Gitter  or  read the latest documentation", 
            "title": "Using the Package"
        }, 
        {
            "location": "/#tutorials", 
            "text": "The following tutorials will introduce you to the functionality of DifferentialEquations.jl   Ordinary Differential Equation (ODE) Example  Stochastic Differential Equation (SDE) Example  Poisson Equation Finite Element Method Example  Heat Equation Finite Element Method Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#manual", 
            "text": "Overview of DifferentialEquations.jl Usage  Defining an ODE Problem  Problem Type  Example Problems    Defining a SDE Problem  Problem Type  Example Problems    Defining a FEM Problem  Poisson Equation Problem  Heat Equation Problem  Example Problems  Related Functions    Defining a Stokes Problem  Problem Type  Example Problems    Meshes  Mesh Specification  Mesh Type  Mesh Generation Functions  Example Meshes  Plot Functions    Information on Solvers  Ordinary Differential Equation Solvers  Stochastic Differential Equation Solvers  Finite Difference Method Solvers  Finite Element Method Solvers    The Solution Type  Solution Types  Related Functions    Plot Functions  Standard Plots  Extra Plot Functions    Convergence Simulations  The ConvergenceSimulation Type  Plot Functions  Related Functions", 
            "title": "Manual"
        }, 
        {
            "location": "/#internal-documentation", 
            "text": "Internal Finite Element Tools  General  Mesh Tools  Solver Tools  Error Tools    Extra Functions  Making Build Work    Solver Helpers  ODE  Stationary Stokes", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "DifferentialEquations  DifferentialEquations.DEFAULT_TABLEAU  DifferentialEquations.ConvergenceSimulation  DifferentialEquations.DEProblem  DifferentialEquations.DESolution  DifferentialEquations.ExplicitRK  DifferentialEquations.FEMSolution  DifferentialEquations.FEMmesh  DifferentialEquations.HeatProblem  DifferentialEquations.Mesh  DifferentialEquations.ODEProblem  DifferentialEquations.ODESolution  DifferentialEquations.PoissonProblem  DifferentialEquations.RosslerSRA  DifferentialEquations.RosslerSRI  DifferentialEquations.SDEProblem  DifferentialEquations.SDESolution  DifferentialEquations.SimpleMesh  DifferentialEquations.StokesProblem  DifferentialEquations.StokesSolution  Base.length  Base.size  DifferentialEquations.CFL\u03bc  DifferentialEquations.CFL\u03bd  DifferentialEquations.FEMSolutionTS  DifferentialEquations.GSu!  DifferentialEquations.GSv!  DifferentialEquations.GS\u03b4q!  DifferentialEquations.accumarray  DifferentialEquations.additiveSDEExample  DifferentialEquations.animate  DifferentialEquations.appxTrue!  DifferentialEquations.assemblematrix  DifferentialEquations.calc_rp!  DifferentialEquations.calc\ud835\udcaaestimates  DifferentialEquations.checkSRAOrder  DifferentialEquations.checkSRIOrder  DifferentialEquations.constructBogakiShampine  DifferentialEquations.constructCashKarp  DifferentialEquations.constructDormandPrince  DifferentialEquations.constructHuen  DifferentialEquations.constructRKF  DifferentialEquations.constructRKF8  DifferentialEquations.constructRalston  DifferentialEquations.constructSRA1  DifferentialEquations.constructSRIW1  DifferentialEquations.conv_ests  DifferentialEquations.cubicSDEExample  DifferentialEquations.dirichletzeroStokesExample  DifferentialEquations.fem_squaremesh  DifferentialEquations.findboundary  DifferentialEquations.getH1error  DifferentialEquations.getL2error  DifferentialEquations.getNoise  DifferentialEquations.heatProblemExample_birthdeath  DifferentialEquations.heatProblemExample_birthdeathinteractingsystem  DifferentialEquations.heatProblemExample_birthdeathsystem  DifferentialEquations.heatProblemExample_diffuse  DifferentialEquations.heatProblemExample_diffusionconstants  DifferentialEquations.heatProblemExample_gierermeinhardt  DifferentialEquations.heatProblemExample_grayscott  DifferentialEquations.heatProblemExample_moving  DifferentialEquations.heatProblemExample_pure  DifferentialEquations.heatProblemExample_stochasticbirthdeath  DifferentialEquations.homogeneousStokesExample  DifferentialEquations.linearODEExample  DifferentialEquations.linearSDEExample  DifferentialEquations.meshExample_Lshapemesh  DifferentialEquations.meshExample_Lshapeunstructure  DifferentialEquations.meshExample_bunny  DifferentialEquations.meshExample_flowpastcylindermesh  DifferentialEquations.meshExample_lakemesh  DifferentialEquations.meshExample_oilpump  DifferentialEquations.meshExample_wavymesh  DifferentialEquations.meshExample_wavyperturbmesh  DifferentialEquations.meshgrid  DifferentialEquations.monteCarloSim  DifferentialEquations.multiDimAdditiveSDEExample  DifferentialEquations.notime_squaremesh  DifferentialEquations.numparameters  DifferentialEquations.parabolic_squaremesh  DifferentialEquations.poissonProblemExample_birthdeath  DifferentialEquations.poissonProblemExample_birthdeathinteractingsystem  DifferentialEquations.poissonProblemExample_birthdeathsystem  DifferentialEquations.poissonProblemExample_noisyWave  DifferentialEquations.poissonProblemExample_wave  DifferentialEquations.quadfbasis  DifferentialEquations.quadpts  DifferentialEquations.quadpts1  DifferentialEquations.setboundary  DifferentialEquations.solve  DifferentialEquations.stokes_prolongation  DifferentialEquations.stokes_restriction  DifferentialEquations.testConvergence  DifferentialEquations.twoDimlinearODEExample  DifferentialEquations.twoDimlinearSDEExample  DifferentialEquations.update_p!  DifferentialEquations.update_u!  DifferentialEquations.update_v!  DifferentialEquations.uzawa_p!  DifferentialEquations.waveSDEExample  DifferentialEquations.\u2207basis  DifferentialEquations.\u2207u", 
            "title": "Index"
        }, 
        {
            "location": "/tutorials/ode/", 
            "text": "Ordinary Differential Equation (ODE) Example\n\n\nIn this example we will solve the equation\n\n\ndu/dt = f(u,t)\n\n\n\n\nwhere \nf(u,t)=\u03b1u\n. We know via Calculus that the solution to this equation is \nu(t)=u\u2080*exp(\u03b1*t)\n. To solve this numerically, we define a problem type by giving it the equation and the initial condition:\n\n\nExample problem with solution ``u(t)=u\u2080*exp(\u03b1*t)``\n\nfunction linearODEExample(;\u03b1=1,u\u2080=1/2)\n  f(u,t) = \u03b1*u\n  sol(u\u2080,t) = u\u2080*exp(\u03b1*t)\n  return(ODEProblem(f,u\u2080,sol=sol))\nend\n\n\n\n\nThen we setup some parameters:\n\n\n\u0394t = 1//2^(4) #The initial step size. It will automatically determined if not given.\ntspan = [0,1] # The timespan. This is the default if not given.\n\n\n\n\nWe then send these items to the solver.\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg=\nEuler\n)\n\n\n\n\nPlotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:\n\n\nplot(sol,plottrue=true)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()\n#Shown is both the true solution and the approximated solution.\n\n\n\n\n\n\nOther Algorithms\n\n\nMore keyword arguments can be found in the Plots.jl documentation. When we plot this solution, we see that it is off from the true solution. We can choose a better algorithm by specifying:\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg=\nExplicitRK\n)\nplot(sol,plottrue=true)\nPlots.gui()\n\n\n\n\nThe \n\"ExplicitRK\"\n algorithms are general Runge-Kutta solvers. It defaults to Dormand-Prince 4/5, the same solver as MATLAB's \node45\n. Please see the solver documentation for more algorithms.\n\n\nNotice that this solution tracks the true solution really well. Thus we can solve the problem in less timesteps by turning on adaptive timestepping. To do so, you simply pass a keyword argument:\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg=\nExplicitRK\n,adaptive=true)\nplot(sol,plottrue=true)\nPlots.gui()\n\n\n\n\n\n\nSystems of Equations\n\n\nWe can also solve systems of equations. DifferentialEquations.jl can handle any size problem, so instead of showing it for a vector, let's let u be a matrix! To do this, we simply need to have u\u2080 be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:\n\n\nExample problem of 8 linear ODEs (as a 4x2 matrix) with\nsolution ``u(t)=exp(\u03b1.*t)`` and random initial conditions\n\nfunction twoDimlinearODEExample(;\u03b1=ones(4,2),u\u2080=rand(4,2).*ones(4,2)/2)\n  f(u,t) = \u03b1.*u\n  sol(u\u2080,t) = u\u2080.*exp(\u03b1.*t)\n  return(ODEProblem(f,u\u2080,sol=sol))\nend\nprob = twoDimlinearODEExample()\n\n\n\n\nHere our ODE is on a 4x2 matrix. Since we are using .*, this is 8 independent ODEs, but you can do whatever you want. To solve the ODE, we do the same steps as before.\n\n\nsol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg=\nExplicitRK\n)\nplot(sol,plottrue=true)\nPlots.gui()\n\n\n\n\nNotice now we have 8 solutions and 8 true solutions, but since we used the high order method, the true solutions are covered by the approximations.", 
            "title": "Ordinary Differential Equation Example"
        }, 
        {
            "location": "/tutorials/ode/#ordinary-differential-equation-ode-example", 
            "text": "In this example we will solve the equation  du/dt = f(u,t)  where  f(u,t)=\u03b1u . We know via Calculus that the solution to this equation is  u(t)=u\u2080*exp(\u03b1*t) . To solve this numerically, we define a problem type by giving it the equation and the initial condition:  Example problem with solution ``u(t)=u\u2080*exp(\u03b1*t)`` \nfunction linearODEExample(;\u03b1=1,u\u2080=1/2)\n  f(u,t) = \u03b1*u\n  sol(u\u2080,t) = u\u2080*exp(\u03b1*t)\n  return(ODEProblem(f,u\u2080,sol=sol))\nend  Then we setup some parameters:  \u0394t = 1//2^(4) #The initial step size. It will automatically determined if not given.\ntspan = [0,1] # The timespan. This is the default if not given.  We then send these items to the solver.  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg= Euler )  Plotting commands are provided via a recipe to Plots.jl. To plot the solution object, simply call plot:  plot(sol,plottrue=true)\n#Use Plots.jl's gui() command to display the plot.\nPlots.gui()\n#Shown is both the true solution and the approximated solution.", 
            "title": "Ordinary Differential Equation (ODE) Example"
        }, 
        {
            "location": "/tutorials/ode/#other-algorithms", 
            "text": "More keyword arguments can be found in the Plots.jl documentation. When we plot this solution, we see that it is off from the true solution. We can choose a better algorithm by specifying:  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg= ExplicitRK )\nplot(sol,plottrue=true)\nPlots.gui()  The  \"ExplicitRK\"  algorithms are general Runge-Kutta solvers. It defaults to Dormand-Prince 4/5, the same solver as MATLAB's  ode45 . Please see the solver documentation for more algorithms.  Notice that this solution tracks the true solution really well. Thus we can solve the problem in less timesteps by turning on adaptive timestepping. To do so, you simply pass a keyword argument:  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg= ExplicitRK ,adaptive=true)\nplot(sol,plottrue=true)\nPlots.gui()", 
            "title": "Other Algorithms"
        }, 
        {
            "location": "/tutorials/ode/#systems-of-equations", 
            "text": "We can also solve systems of equations. DifferentialEquations.jl can handle any size problem, so instead of showing it for a vector, let's let u be a matrix! To do this, we simply need to have u\u2080 be a matrix, and define f such that it takes in a matrix and outputs a matrix. We can define a matrix of linear ODEs as follows:  Example problem of 8 linear ODEs (as a 4x2 matrix) with\nsolution ``u(t)=exp(\u03b1.*t)`` and random initial conditions \nfunction twoDimlinearODEExample(;\u03b1=ones(4,2),u\u2080=rand(4,2).*ones(4,2)/2)\n  f(u,t) = \u03b1.*u\n  sol(u\u2080,t) = u\u2080.*exp(\u03b1.*t)\n  return(ODEProblem(f,u\u2080,sol=sol))\nend\nprob = twoDimlinearODEExample()  Here our ODE is on a 4x2 matrix. Since we are using .*, this is 8 independent ODEs, but you can do whatever you want. To solve the ODE, we do the same steps as before.  sol =solve(prob::ODEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg= ExplicitRK )\nplot(sol,plottrue=true)\nPlots.gui()  Notice now we have 8 solutions and 8 true solutions, but since we used the high order method, the true solutions are covered by the approximations.", 
            "title": "Systems of Equations"
        }, 
        {
            "location": "/tutorials/sde/", 
            "text": "Stochastic Differential Equation (SDE) Example\n\n\nIn this example we will solve the equation\n\n\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n\n\n\n\nwhere \nf(u,t)=\u03b1u\n and \n\u03c3(u,t)=\u03b2u\n. We know via Stochastic Calculus that the solution to this equation is \nu(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\n. To solve this numerically, we define a problem type by giving it the equation and the initial condition:\n\n\nExample problem with solution ``u(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)``\n\nfunction linearSDEExample(;\u03b1=1,\u03b2=1,u\u2080=1/2)\n  f(u,t) = \u03b1*u\n  \u03c3(u,t) = \u03b2*u\n  sol(u\u2080,t,W) = u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\n  return(SDEProblem(f,\u03c3,u\u2080,sol=sol))\nend\nprob = linearSDEExample()\n\u0394t = 1//2^(4) #The initial timestepping size. It will automatically assigned if not given.\ntspan = [0,1] # The timespan. This is the default if not given.\n\n\n\n\nand then we pass this information to the solver and plot:\n\n\n#We can plot using the classic Euler-Maruyama algorithm as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg=\nEM\n)\nplot(sol,plottrue=true)\n#Use Plots.jl's gui() command to display the plot.\ngui()\n\n\n\n\nWe can choose a better solver as well:\n\n\n#We can choose a better method as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg=\nSRI\n)\nplot(sol,plottrue=true)\ngui()", 
            "title": "Stochastic Differential Equation Example"
        }, 
        {
            "location": "/tutorials/sde/#stochastic-differential-equation-sde-example", 
            "text": "In this example we will solve the equation  du = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071  where  f(u,t)=\u03b1u  and  \u03c3(u,t)=\u03b2u . We know via Stochastic Calculus that the solution to this equation is  u(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W) . To solve this numerically, we define a problem type by giving it the equation and the initial condition:  Example problem with solution ``u(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)`` \nfunction linearSDEExample(;\u03b1=1,\u03b2=1,u\u2080=1/2)\n  f(u,t) = \u03b1*u\n  \u03c3(u,t) = \u03b2*u\n  sol(u\u2080,t,W) = u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\n  return(SDEProblem(f,\u03c3,u\u2080,sol=sol))\nend\nprob = linearSDEExample()\n\u0394t = 1//2^(4) #The initial timestepping size. It will automatically assigned if not given.\ntspan = [0,1] # The timespan. This is the default if not given.  and then we pass this information to the solver and plot:  #We can plot using the classic Euler-Maruyama algorithm as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg= EM )\nplot(sol,plottrue=true)\n#Use Plots.jl's gui() command to display the plot.\ngui()  We can choose a better solver as well:  #We can choose a better method as follows:\nsol =solve(prob::SDEProblem,tspan,\u0394t=\u0394t,fullSave=true,alg= SRI )\nplot(sol,plottrue=true)\ngui()", 
            "title": "Stochastic Differential Equation (SDE) Example"
        }, 
        {
            "location": "/tutorials/femPoisson/", 
            "text": "Poisson Equation Finite Element Method Example\n\n\nIn this example we will solve the Poisson Equation \n\u0394u=f\n. The code for this example can be found in \ntest/introductionExample.jl\n. For our example, we will take the linear equation where \nf(x,y) = sin(2\u03c0.*x).*cos(2\u03c0.*y)\n. For this equation we know that solution is \nu(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n with gradient \nDu(x,y) = [cos(2*pi.*x).*cos(2*pi.*y)./(4*pi) -sin(2\u03c0.*x).*sin(2\u03c0.*y)./(4\u03c0)]\n. Thus, we define a PoissonProblem as follows:\n\n\nExample problem with solution: ``u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)``\n\nfunction poissonProblemExample_wave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  return(PoissonProblem(f,sol,Du))\nend\nprob = poissonProblemExample_wave()\n\n\n\n\nNote that in this case since the solution is known, the Dirichlet boundary condition \ngD\n is automatically set to match the true solution. The code for other example problems can be found in \nsrc/examples/exampleProblems.jl\n. To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:\n\n\n\u0394x = 1//2^(5)\nfemMesh = notime_squaremesh([0 1 0 1],\u0394x,\nDirichlet\n)\n\n\n\n\nNote that by specifying \"Dirichlet\" our boundary conditions is set on all boundaries to Dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as \niFEM\n. Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use\n\n\nsol = solve(femMesh,pdeProb)\n\n\n\n\nfem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This reurns a FEMSolution object which holds data about the solution, such as the solution values (u), the true solution (uTrue), error estimates, etc. To plot the solution, we use the command\n\n\nplot(sol::FEMSolution,plottrue=true)\n\n\n\n\nThis gives us the following plot:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femPoisson/#poisson-equation-finite-element-method-example", 
            "text": "In this example we will solve the Poisson Equation  \u0394u=f . The code for this example can be found in  test/introductionExample.jl . For our example, we will take the linear equation where  f(x,y) = sin(2\u03c0.*x).*cos(2\u03c0.*y) . For this equation we know that solution is  u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  with gradient  Du(x,y) = [cos(2*pi.*x).*cos(2*pi.*y)./(4*pi) -sin(2\u03c0.*x).*sin(2\u03c0.*y)./(4\u03c0)] . Thus, we define a PoissonProblem as follows:  Example problem with solution: ``u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)`` \nfunction poissonProblemExample_wave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  return(PoissonProblem(f,sol,Du))\nend\nprob = poissonProblemExample_wave()  Note that in this case since the solution is known, the Dirichlet boundary condition  gD  is automatically set to match the true solution. The code for other example problems can be found in  src/examples/exampleProblems.jl . To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:  \u0394x = 1//2^(5)\nfemMesh = notime_squaremesh([0 1 0 1],\u0394x, Dirichlet )  Note that by specifying \"Dirichlet\" our boundary conditions is set on all boundaries to Dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as  iFEM . Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use  sol = solve(femMesh,pdeProb)  fem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This reurns a FEMSolution object which holds data about the solution, such as the solution values (u), the true solution (uTrue), error estimates, etc. To plot the solution, we use the command  plot(sol::FEMSolution,plottrue=true)  This gives us the following plot:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femHeat/", 
            "text": "Heat Equation Finite Element Method Example\n\n\nIn this example we will solve the heat equation \nu_t=\u0394u+f\n. To do this, we define a HeatProblem which contains the function \nf\n and the boundary conditions. We specify one as follows:\n\n\nExample problem which starts with 0 and solves with ``f(u)=1-u/2``\n\nfunction heatProblemExample_birthdeath()\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u\u2080(x) = zeros(size(x,1))\n  return(HeatProblem(u\u2080,f))\nend\nprob = heatProblemExample_birthdeath()\n\n\n\n\nHere the equation we chose was nonlinear since \nf\n depends on the variable \nu\n. Thus we specify f=f(u,x,t). If \nf\n did not depend on u, then we would specify f=f(x,t). We do need to specify \ngD\n (the Dirichlet boundary condition) and \ngN\n (the Neumann boundary condition) since both are zero. \nu0\n specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.\n\n\nWe then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command\n\n\nT = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,\nNeumann\n)\n\n\n\n\nWe then call the solver\n\n\nsol = solve(femMesh::FEMmesh,prob::HeatProblem,alg=\nEuler\n)\n\n\n\n\nHere we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femHeat/#heat-equation-finite-element-method-example", 
            "text": "In this example we will solve the heat equation  u_t=\u0394u+f . To do this, we define a HeatProblem which contains the function  f  and the boundary conditions. We specify one as follows:  Example problem which starts with 0 and solves with ``f(u)=1-u/2`` \nfunction heatProblemExample_birthdeath()\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u\u2080(x) = zeros(size(x,1))\n  return(HeatProblem(u\u2080,f))\nend\nprob = heatProblemExample_birthdeath()  Here the equation we chose was nonlinear since  f  depends on the variable  u . Thus we specify f=f(u,x,t). If  f  did not depend on u, then we would specify f=f(x,t). We do need to specify  gD  (the Dirichlet boundary condition) and  gN  (the Neumann boundary condition) since both are zero.  u0  specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.  We then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command  T = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T, Neumann )  We then call the solver  sol = solve(femMesh::FEMmesh,prob::HeatProblem,alg= Euler )  Here we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femStochastic/", 
            "text": "Stochastic Finite Element Examples\n\n\nFor most problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments \ndW\n, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noiseType which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.\n\n\nThe following examples show how to change the tutorial problems into stochastic problems.\n\n\n\n\nFinite Element Stochastic Poisson Equation\n\n\nWe can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  \n-\u0394u=f+gdW\n, with additive space-time white noise by specifying the problem as:\n\n\nExample problem with deterministic solution: ``u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)``\n\nfunction poissonProblemExample_noisyWave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  \u03c3(x) = 5 #Additive noise\n  return(PoissonProblem(f,sol,Du,\u03c3=\u03c3))\nend\n\n\n\n\nusing the same solving commands as shown in \nfemStochasticPoissonSolo.jl\n. This gives the following plot:\n\n\n\n\n\n\nFinite Element Stochastic Heat Equation\n\n\nThis will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function \nf(u)=.5-u\n, noise function \ng(u)=100u^2\n and initial condition \nu0=0\n. We would expect this system to rise towards the deterministic steady state \nu=2\n (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:\n\n\nExample problem which starts with 0 and solves with ``f(u)=1-u/2`` with noise ``\u03c3(u)=10u^2``\n\nfunction heatProblemExample_stochasticbirthdeath()\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u\u2080(x) = zeros(size(x,1))\n  \u03c3(u,x,t) = 1u.^2\n  return(HeatProblem(u\u2080,f,\u03c3=\u03c3))\nend\n\n\n\n\nAs shown in \nfemStochasticHeatAnimationTest.jl\n, we use the following code create an animation of the solution:\n\n\nT = 5\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(11)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,\nNeumann\n)\nprob = heatProblemExample_stochasticbirthdeath()\n\nsol = solve(femMesh::FEMmesh,prob::HeatProblem,alg=\nEuler\n,fullSave=true,solver=\nLU\n)\nanimate(sol::FEMSolution;zlim=(0,3),cbar=false)", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femStochastic/#stochastic-finite-element-examples", 
            "text": "For most problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments  dW , and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noiseType which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.  The following examples show how to change the tutorial problems into stochastic problems.", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femStochastic/#finite-element-stochastic-poisson-equation", 
            "text": "We can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,   -\u0394u=f+gdW , with additive space-time white noise by specifying the problem as:  Example problem with deterministic solution: ``u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)`` \nfunction poissonProblemExample_noisyWave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  \u03c3(x) = 5 #Additive noise\n  return(PoissonProblem(f,sol,Du,\u03c3=\u03c3))\nend  using the same solving commands as shown in  femStochasticPoissonSolo.jl . This gives the following plot:", 
            "title": "Finite Element Stochastic Poisson Equation"
        }, 
        {
            "location": "/tutorials/femStochastic/#finite-element-stochastic-heat-equation", 
            "text": "This will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function  f(u)=.5-u , noise function  g(u)=100u^2  and initial condition  u0=0 . We would expect this system to rise towards the deterministic steady state  u=2  (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:  Example problem which starts with 0 and solves with ``f(u)=1-u/2`` with noise ``\u03c3(u)=10u^2`` \nfunction heatProblemExample_stochasticbirthdeath()\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u\u2080(x) = zeros(size(x,1))\n  \u03c3(u,x,t) = 1u.^2\n  return(HeatProblem(u\u2080,f,\u03c3=\u03c3))\nend  As shown in  femStochasticHeatAnimationTest.jl , we use the following code create an animation of the solution:  T = 5\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(11)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T, Neumann )\nprob = heatProblemExample_stochasticbirthdeath()\n\nsol = solve(femMesh::FEMmesh,prob::HeatProblem,alg= Euler ,fullSave=true,solver= LU )\nanimate(sol::FEMSolution;zlim=(0,3),cbar=false)", 
            "title": "Finite Element Stochastic Heat Equation"
        }, 
        {
            "location": "/man/overview/", 
            "text": "Overview of DifferentialEquations.jl Usage\n\n\nThe general workflow for using the package is as follows:\n\n\n\n\nDefine a problem\n\n\nGenerate a mesh\n\n\nUse a solver on the problem and mesh\n\n\nAnalyze the output\n\n\n\n\nProblems are specified via a type interface. For example, for the Poisson equation \n\u0394u = f\n, one defines a type which holds \nf\n and the boundary condition functions.\n\n\nNext, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. [0,1]^2 x [0,T], then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.\n\n\nOne then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.\n\n\nWith the solution object, you do the analysis as you please! For some result \nsol\n, the field \nsol.u\n returns the final solution, and if you give a true solution, \nsol.uTrue\n is the true solution at the final time. If you specified to the solver \nfullSave=true\n, then \nsol.uFull\n and \nsol.tFull\n will be outputted which hold the solution/time at every \nsaveSteps\n (default set to 100, meaning it saves an output every 100 steps).\n\n\nPlotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the \nplot(type)\n and the plotter will generate appropriate plots. If \nfullSave\n was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.\n\n\nDifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. An array of solutions can be made into a \nConvergenceSimulation\n which then generates all of the convergence test results and allows for plotting (great for developing new methods!).", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#overview-of-differentialequationsjl-usage", 
            "text": "The general workflow for using the package is as follows:   Define a problem  Generate a mesh  Use a solver on the problem and mesh  Analyze the output   Problems are specified via a type interface. For example, for the Poisson equation  \u0394u = f , one defines a type which holds  f  and the boundary condition functions.  Next, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. [0,1]^2 x [0,T], then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.  One then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.  With the solution object, you do the analysis as you please! For some result  sol , the field  sol.u  returns the final solution, and if you give a true solution,  sol.uTrue  is the true solution at the final time. If you specified to the solver  fullSave=true , then  sol.uFull  and  sol.tFull  will be outputted which hold the solution/time at every  saveSteps  (default set to 100, meaning it saves an output every 100 steps).  Plotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the  plot(type)  and the plotter will generate appropriate plots. If  fullSave  was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.  DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. An array of solutions can be made into a  ConvergenceSimulation  which then generates all of the convergence test results and allows for plotting (great for developing new methods!).", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/odeProblem/", 
            "text": "Defining an ODE Problem\n\n\nTo define an ODE Problem, you simply need to give the function \nf\n and the initial condition \nu\u2080\n which define an ODE\n\n\ndu/dt = f(u,t)dt\n\n\n\n\nf\n should be specified as \nf(u,t)\n and \nu\u2080\n should be an AbstractArray whose geometry matches the desired geometry of \nu\n. Note that we are not limited to numbers or vectors for \nu\u2080\n, one is allowed to provide \nu\u2080\n as arbitrary matrices / higher dimension tensors as well.\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.ODEProblem\n \n \nType\n.\n\n\nODEProblem\n\n\nWraps the data which defines an SDE problem\n\n\nu\u209c = f(u\u209c,t)dt\n\n\n\n\nwith initial condition u\u2080.\n\n\nFields\n\n\n\n\nf\n: The drift function in the ODE.\n\n\nu\u2080\n: The initial condition.\n\n\nsol\n: A function which describes the solution.\n\n\nknownSol\n: True if the solution is given.\n\n\nnumVars\n: The number of variables in the system\n\n\nsizeu\n: The size of the initial condition (and thus \nu\n)\n\n\n\n\nConstructors\n\n\nODEProblem(f,u\u2080;sol=nothing) : Defines the SDE with the specified functions and defines the solution if sol is given.\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.twoDimlinearODEExample\n \n \nFunction\n.\n\n\nExample problem of 8 linear ODEs (as a 4x2 matrix) with solution \nu(t)=exp(\u03b1.*t)\n and random initial conditions\n\n\n#\n\n\nDifferentialEquations.linearODEExample\n \n \nFunction\n.\n\n\nExample problem with solution \nu(t)=u\u2080*exp(\u03b1*t)", 
            "title": "Defining an ODE Problem"
        }, 
        {
            "location": "/man/odeProblem/#defining-an-ode-problem", 
            "text": "To define an ODE Problem, you simply need to give the function  f  and the initial condition  u\u2080  which define an ODE  du/dt = f(u,t)dt  f  should be specified as  f(u,t)  and  u\u2080  should be an AbstractArray whose geometry matches the desired geometry of  u . Note that we are not limited to numbers or vectors for  u\u2080 , one is allowed to provide  u\u2080  as arbitrary matrices / higher dimension tensors as well.", 
            "title": "Defining an ODE Problem"
        }, 
        {
            "location": "/man/odeProblem/#problem-type", 
            "text": "#  DifferentialEquations.ODEProblem     Type .  ODEProblem  Wraps the data which defines an SDE problem  u\u209c = f(u\u209c,t)dt  with initial condition u\u2080.  Fields   f : The drift function in the ODE.  u\u2080 : The initial condition.  sol : A function which describes the solution.  knownSol : True if the solution is given.  numVars : The number of variables in the system  sizeu : The size of the initial condition (and thus  u )   Constructors  ODEProblem(f,u\u2080;sol=nothing) : Defines the SDE with the specified functions and defines the solution if sol is given.", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/odeProblem/#example-problems", 
            "text": "#  DifferentialEquations.twoDimlinearODEExample     Function .  Example problem of 8 linear ODEs (as a 4x2 matrix) with solution  u(t)=exp(\u03b1.*t)  and random initial conditions  #  DifferentialEquations.linearODEExample     Function .  Example problem with solution  u(t)=u\u2080*exp(\u03b1*t)", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/sdeProblem/", 
            "text": "Defining a SDE Problem\n\n\nTo define an SDE Problem, you simply need to give the forcing function \nf\n, the noise function \n\u03c3\n, and the initial condition \nu\u2080\n which define an SDE\n\n\ndu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n\n\n\n\nf\n and \n\u03c3\n should be specified as \nf(u,t)\n and  \n\u03c3(u,t)\n respectively, and \nu\u2080\n should be an AbstractArray whose geometry matches the desired geometry of \nu\n. Note that we are not limited to numbers or vectors for \nu\u2080\n, one is allowed to provide \nu\u2080\n as arbitrary matrices / higher dimension tensors as well. A vector of \n\u03c3\ns can also be defined to determine an SDE of higher Ito dimension.\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.SDEProblem\n \n \nType\n.\n\n\nSDEProblem\n\n\nWraps the data which defines an SDE problem\n\n\nu = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071\n\n\n\n\nwith initial condition u\u2080.\n\n\nFields\n\n\n\n\nf\n: The drift function in the SDE.\n\n\n\u03c3\n: The noise function in the SDE.\n\n\nu\u2080\n: The initial condition.\n\n\nsol\n: A function which describes the solution.\n\n\nknownSol\n: True if the solution is given.\n\n\nnumVars\n: The number of variables in the system\n\n\nsizeu\n: The size of the initial condition (and thus \nu\n)\n\n\n\n\nConstructors\n\n\nSDEProblem(f,\u03c3,u\u2080;sol=nothing) : Defines the SDE with the specified functions and defines the solution if sol is given.\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.twoDimlinearSDEExample\n \n \nFunction\n.\n\n\nExample problem of 8 linear SDEs (as a 4x2 matrix) with solution \nu(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\n\n\n#\n\n\nDifferentialEquations.cubicSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution \nu(t,W)=((1+u\u2080)*exp(W)+u\u2080-1)./((1+u\u2080)*exp(W)+1-u\u2080)\n\n\n#\n\n\nDifferentialEquations.linearSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution \nu(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)\n\n\n#\n\n\nDifferentialEquations.multiDimAdditiveSDEExample\n \n \nFunction\n.\n\n\nMultiple Ito dimension extension of additiveSDEExample\n\n\n#\n\n\nDifferentialEquations.waveSDEExample\n \n \nFunction\n.\n\n\nExample problem with solution \nu(t,W)=atan(0.1*W + tan(u\u2080))\n\n\n#\n\n\nDifferentialEquations.additiveSDEExample\n \n \nFunction\n.\n\n\nExample additive noise problem with solution \nu\u2080./sqrt(1+t) + \u03b2*(t+\u03b1*W)./sqrt(1+t)", 
            "title": "Defining an SDE Problem"
        }, 
        {
            "location": "/man/sdeProblem/#defining-a-sde-problem", 
            "text": "To define an SDE Problem, you simply need to give the forcing function  f , the noise function  \u03c3 , and the initial condition  u\u2080  which define an SDE  du = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071  f  and  \u03c3  should be specified as  f(u,t)  and   \u03c3(u,t)  respectively, and  u\u2080  should be an AbstractArray whose geometry matches the desired geometry of  u . Note that we are not limited to numbers or vectors for  u\u2080 , one is allowed to provide  u\u2080  as arbitrary matrices / higher dimension tensors as well. A vector of  \u03c3 s can also be defined to determine an SDE of higher Ito dimension.", 
            "title": "Defining a SDE Problem"
        }, 
        {
            "location": "/man/sdeProblem/#problem-type", 
            "text": "#  DifferentialEquations.SDEProblem     Type .  SDEProblem  Wraps the data which defines an SDE problem  u = f(u,t)dt + \u03a3\u03c3\u1d62(u,t)dW\u2071  with initial condition u\u2080.  Fields   f : The drift function in the SDE.  \u03c3 : The noise function in the SDE.  u\u2080 : The initial condition.  sol : A function which describes the solution.  knownSol : True if the solution is given.  numVars : The number of variables in the system  sizeu : The size of the initial condition (and thus  u )   Constructors  SDEProblem(f,\u03c3,u\u2080;sol=nothing) : Defines the SDE with the specified functions and defines the solution if sol is given.", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/sdeProblem/#example-problems", 
            "text": "#  DifferentialEquations.twoDimlinearSDEExample     Function .  Example problem of 8 linear SDEs (as a 4x2 matrix) with solution  u(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)  #  DifferentialEquations.cubicSDEExample     Function .  Example problem with solution  u(t,W)=((1+u\u2080)*exp(W)+u\u2080-1)./((1+u\u2080)*exp(W)+1-u\u2080)  #  DifferentialEquations.linearSDEExample     Function .  Example problem with solution  u(t,W)=u\u2080*exp((\u03b1-(\u03b2^2)/2)*t+\u03b2*W)  #  DifferentialEquations.multiDimAdditiveSDEExample     Function .  Multiple Ito dimension extension of additiveSDEExample  #  DifferentialEquations.waveSDEExample     Function .  Example problem with solution  u(t,W)=atan(0.1*W + tan(u\u2080))  #  DifferentialEquations.additiveSDEExample     Function .  Example additive noise problem with solution  u\u2080./sqrt(1+t) + \u03b2*(t+\u03b1*W)./sqrt(1+t)", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/femProblem/", 
            "text": "Defining a FEM Problem\n\n\nBelow are the definitions of the types which specify problems. Some general notes are:\n\n\n\n\n(x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as \nf(x,y,t)\n. However, in this code we use \nx\n as a vector. Thus you can think of \nx\n=\nx[:,1]\n and \ny\n=\nx[:,2]\n. Thus input equations are of the form \nf(x,t)\n no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use \nf(x)\n. An example is the equation \nu(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n would be specified as \nsol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n.\n\n\nLinearity: If the equation has linear term, they are specified with functions \nf(x,t)\n. If it is nonlinear, it is specified with functions \nf(u,x,t)\n. The boundary conditions are always \n(x,t)\n\n\nStochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic \n\u03c3(u,x,t)dW_t\n term to the equation (or with \n\u03c3(x,t)dW_t\n if linear, must match \nf\n). \ndW_t\n corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.\n\n\n\n\n\n\nPoisson Equation Problem\n\n\n#\n\n\nDifferentialEquations.PoissonProblem\n \n \nType\n.\n\n\nPoissonProblem\n\n\nWraps the data that define a 2D linear Poisson equation problem:\n\n\n-\u0394u = f\n\n\n\n\nwith bounday conditions \ngD\n on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\n-\u0394u = f + \u03c3dW\n\n\n\n\nConstructors\n\n\nPoissonProblem(f,sol,Du): Defines the Dirichlet problem with solution \nsol\n, solution gradient \nDu = [u_x,u_y]\n, and forcing function \nf\n\n\nPoissonProblem(u\u2080,f): Defines the problem with initial value \nu\u2080\n (as a function) and f. If your initial data is a vector, wrap it as u\u2080(x) = vector.\n\n\nNote: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))\n\n\nKeyword Arguments\n\n\n\n\n\n\ngD\n = Dirichlet boundary function\n\n\n\n\n\n\ngN\n = Neumann boundary function\n\n\n\n\n\n\n\u03c3\n = The function which multiplies the noise \ndW\n. By default \n\u03c3\n is 0.\n\n\n\n\n\n\nnoiseType\n = A string which specifies the type of noise to be generated. By default \nnoiseType\n is \"White\" for Gaussian Spacetime White Noise.\n\n\n\n\n\n\nnumVars\n = The number of variables in the Poisson system. Automatically calculated in many cases.\n\n\n\n\n\n\nD\n = Vector of diffusion coefficients. Defaults to ones.\n\n\n\n\n\n\n\n\nHeat Equation Problem\n\n\n#\n\n\nDifferentialEquations.HeatProblem\n \n \nType\n.\n\n\nHeatProblem\n\n\nWraps the data that define a 2D heat equation problem:\n\n\nu_t = \u0394u + f\n\n\n\n\nwith bounday conditions \ngD\n on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function \nf\n is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).\n\n\nIf they keyword \n\u03c3\n is given, then this wraps the data that define a 2D stochastic heat equation\n\n\nu_t = \u0394u + f + \u03c3dW_t\n\n\n\n\nConstructors\n\n\n\n\n\n\nHeatProblem(sol,Du,f)\n: Defines the Dirichlet problem with solution \nsol\n, solution gradient \nDu = [u_x,u_y]\n, and the forcing function \nf\n.\n\n\n\n\n\n\nHeatProblem(u\u2080,f)\n: Defines the problem with initial value \nu\u2080\n (as a function) and \nf\n. If your initial data is a vector, wrap it as u\u2080(x) = vector.\n\n\n\n\n\n\nNote: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))\n\n\nKeyword Arguments\n\n\n\n\n\n\ngD\n = Dirichlet boundary function\n\n\n\n\n\n\ngN\n = Neumann boundary function\n\n\n\n\n\n\n\u03c3\n = The function which multiplies the noise dW. By default \u03c3 is 0.\n\n\n\n\n\n\nnoiseType\n = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.\n\n\n\n\n\n\nnumVars\n = Number of variables in the system. Automatically calculated from u\u2080 in most cases.\n\n\n\n\n\n\nD\n = Array which defines the diffusion coefficients. Defaults to 1's.\n\n\n\n\n\n\n\n\nExample Problems\n\n\n\n\nPoisson Equation\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_wave\n \n \nFunction\n.\n\n\nExample problem with solution: \nu(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n \n \nFunction\n.\n\n\nExample problem with deterministic solution: \nu(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem for nonlinear Poisson equation. Uses \nf(u)=1-u/2\n.\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeathinteractingsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system \nf(u)=1-u/2\n and \nf(v)=.5u-v\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeathsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system \nf(u)=1-u/2\n and \nf(v)=1-v\n\n\n\n\nHeat Equation\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffuse\n \n \nFunction\n.\n\n\nExample problem with solution: \nu(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_pure\n \n \nFunction\n.\n\n\nExample problem which starts with 1 at (0.5,0.5) and solves with \nf=gD=0\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_moving\n \n \nFunction\n.\n\n\nExample problem with solution: \nu(x,y,t)=0.1*(1-exp(-100*(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with \nf(u)=1-u/2\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with \nf(u)=1-u/2\n with noise \n\u03c3(u)=10u^2\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeathinteractingsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system \nf(u)=1-u/2\n and \nf(v)=.5u-v\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_gierermeinhardt\n \n \nFunction\n.\n\n\nExample problem which solves the Gierer-Meinhardt equations wtih quasi-random initial perturbations.\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeathsystem\n \n \nFunction\n.\n\n\nExample problem which starts with 1/2 and solves the system \nf(u)=1-u/2\n and \nf(v)=1-v\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffusionconstants\n \n \nFunction\n.\n\n\nExample problem which solves the homogeneous Heat equation with all mass starting at (1/2,1/2) with two different diffusion constants.\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_grayscott\n \n \nFunction\n.\n\n\nExample problem which solves the Gray-Scott equations with quasi-random initial conditions\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.DEProblem\n \n \nType\n.\n\n\nPdeProblem: Defines differential equation problems via its internal functions", 
            "title": "Defining a Finite Element Problem"
        }, 
        {
            "location": "/man/femProblem/#defining-a-fem-problem", 
            "text": "Below are the definitions of the types which specify problems. Some general notes are:   (x,t) vs (x,y,t): Mathematically one normally specifies equations in 2D as  f(x,y,t) . However, in this code we use  x  as a vector. Thus you can think of  x = x[:,1]  and  y = x[:,2] . Thus input equations are of the form  f(x,t)  no matter the dimension. If time is not included in the problem (for example, a Poisson equation problem), then we use  f(x) . An example is the equation  u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  would be specified as  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0) .  Linearity: If the equation has linear term, they are specified with functions  f(x,t) . If it is nonlinear, it is specified with functions  f(u,x,t) . The boundary conditions are always  (x,t)  Stochastic: By default the equation is deterministic. For each equation, one can specify a \u03c3 term which adds a stochastic  \u03c3(u,x,t)dW_t  term to the equation (or with  \u03c3(x,t)dW_t  if linear, must match  f ).  dW_t  corresponds to the type of noise which is chosen. By default this is space-time Gaussian white noise.", 
            "title": "Defining a FEM Problem"
        }, 
        {
            "location": "/man/femProblem/#poisson-equation-problem", 
            "text": "#  DifferentialEquations.PoissonProblem     Type .  PoissonProblem  Wraps the data that define a 2D linear Poisson equation problem:  -\u0394u = f  with bounday conditions  gD  on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  -\u0394u = f + \u03c3dW", 
            "title": "Poisson Equation Problem"
        }, 
        {
            "location": "/man/femProblem/#constructors", 
            "text": "PoissonProblem(f,sol,Du): Defines the Dirichlet problem with solution  sol , solution gradient  Du = [u_x,u_y] , and forcing function  f  PoissonProblem(u\u2080,f): Defines the problem with initial value  u\u2080  (as a function) and f. If your initial data is a vector, wrap it as u\u2080(x) = vector.  Note: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/femProblem/#keyword-arguments", 
            "text": "gD  = Dirichlet boundary function    gN  = Neumann boundary function    \u03c3  = The function which multiplies the noise  dW . By default  \u03c3  is 0.    noiseType  = A string which specifies the type of noise to be generated. By default  noiseType  is \"White\" for Gaussian Spacetime White Noise.    numVars  = The number of variables in the Poisson system. Automatically calculated in many cases.    D  = Vector of diffusion coefficients. Defaults to ones.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/femProblem/#heat-equation-problem", 
            "text": "#  DifferentialEquations.HeatProblem     Type .  HeatProblem  Wraps the data that define a 2D heat equation problem:  u_t = \u0394u + f  with bounday conditions  gD  on the Dirichlet boundary and gN on the Neumann boundary. Linearity is determined by whether the forcing function  f  is a function of two variables (x,t) or three (u,x,t) (with x=[:,1] and y=[:,2]).  If they keyword  \u03c3  is given, then this wraps the data that define a 2D stochastic heat equation  u_t = \u0394u + f + \u03c3dW_t", 
            "title": "Heat Equation Problem"
        }, 
        {
            "location": "/man/femProblem/#constructors_1", 
            "text": "HeatProblem(sol,Du,f) : Defines the Dirichlet problem with solution  sol , solution gradient  Du = [u_x,u_y] , and the forcing function  f .    HeatProblem(u\u2080,f) : Defines the problem with initial value  u\u2080  (as a function) and  f . If your initial data is a vector, wrap it as u\u2080(x) = vector.    Note: If all functions are of (x,t), then the program assumes it's linear. Write your functions using x = x[:,1] and y = x[:,2].  Use f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified) for nonlinear problems (with the boundary conditions still (x,t))", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/femProblem/#keyword-arguments_1", 
            "text": "gD  = Dirichlet boundary function    gN  = Neumann boundary function    \u03c3  = The function which multiplies the noise dW. By default \u03c3 is 0.    noiseType  = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.    numVars  = Number of variables in the system. Automatically calculated from u\u2080 in most cases.    D  = Array which defines the diffusion coefficients. Defaults to 1's.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/femProblem/#example-problems", 
            "text": "", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/femProblem/#poisson-equation", 
            "text": "#  DifferentialEquations.poissonProblemExample_wave     Function .  Example problem with solution:  u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  #  DifferentialEquations.poissonProblemExample_noisyWave     Function .  Example problem with deterministic solution:  u(x,y)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  #  DifferentialEquations.poissonProblemExample_birthdeath     Function .  Example problem for nonlinear Poisson equation. Uses  f(u)=1-u/2 .  #  DifferentialEquations.poissonProblemExample_birthdeathinteractingsystem     Function .  Example problem which starts with 1/2 and solves the system  f(u)=1-u/2  and  f(v)=.5u-v  #  DifferentialEquations.poissonProblemExample_birthdeathsystem     Function .  Example problem which starts with 1/2 and solves the system  f(u)=1-u/2  and  f(v)=1-v", 
            "title": "Poisson Equation"
        }, 
        {
            "location": "/man/femProblem/#heat-equation", 
            "text": "#  DifferentialEquations.heatProblemExample_diffuse     Function .  Example problem with solution:  u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)  #  DifferentialEquations.heatProblemExample_pure     Function .  Example problem which starts with 1 at (0.5,0.5) and solves with  f=gD=0  #  DifferentialEquations.heatProblemExample_moving     Function .  Example problem with solution:  u(x,y,t)=0.1*(1-exp(-100*(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))  #  DifferentialEquations.heatProblemExample_birthdeath     Function .  Example problem which starts with 0 and solves with  f(u)=1-u/2  #  DifferentialEquations.heatProblemExample_stochasticbirthdeath     Function .  Example problem which starts with 0 and solves with  f(u)=1-u/2  with noise  \u03c3(u)=10u^2  #  DifferentialEquations.heatProblemExample_birthdeathinteractingsystem     Function .  Example problem which starts with 1/2 and solves the system  f(u)=1-u/2  and  f(v)=.5u-v  #  DifferentialEquations.heatProblemExample_gierermeinhardt     Function .  Example problem which solves the Gierer-Meinhardt equations wtih quasi-random initial perturbations.  #  DifferentialEquations.heatProblemExample_birthdeathsystem     Function .  Example problem which starts with 1/2 and solves the system  f(u)=1-u/2  and  f(v)=1-v  #  DifferentialEquations.heatProblemExample_diffusionconstants     Function .  Example problem which solves the homogeneous Heat equation with all mass starting at (1/2,1/2) with two different diffusion constants.  #  DifferentialEquations.heatProblemExample_grayscott     Function .  Example problem which solves the Gray-Scott equations with quasi-random initial conditions", 
            "title": "Heat Equation"
        }, 
        {
            "location": "/man/femProblem/#related-functions", 
            "text": "#  DifferentialEquations.DEProblem     Type .  PdeProblem: Defines differential equation problems via its internal functions", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/stokesProblem/", 
            "text": "Defining a Stokes Problem\n\n\n\n\nProblem Type\n\n\n#\n\n\nDifferentialEquations.StokesProblem\n \n \nType\n.\n\n\nStokesProblem\n\n\nDefines the solution to a stationary Stokes problem:\n\n\n\n\n\n\nFields\n\n\n\n\nf\u2081::Function\n\n\nf\u2082::Function\n\n\ng::Function\n\n\nugD::Function\n\n\nvgD::Function\n\n\nusol::Function\n\n\nvsol::Function\n\n\npsol::Function\n\n\ntrueKnown::Bool\n\n\n\n\nConstructors\n\n\nStokesProblem(f\u2081,f\u2082,g,usol,vsol,psol)\n\n\nStokesProblem(f\u2081,f\u2082,g,ugD,vgD)\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.dirichletzeroStokesExample\n \n \nFunction\n.\n\n\nExample problme for solving the trivial stationary Stokes equation.\n\n\n#\n\n\nDifferentialEquations.homogeneousStokesExample\n \n \nFunction\n.\n\n\nExample problem for a homogeneous stationary Stokes equation.", 
            "title": "Defining a Stokes Problem"
        }, 
        {
            "location": "/man/stokesProblem/#defining-a-stokes-problem", 
            "text": "", 
            "title": "Defining a Stokes Problem"
        }, 
        {
            "location": "/man/stokesProblem/#problem-type", 
            "text": "#  DifferentialEquations.StokesProblem     Type .  StokesProblem  Defines the solution to a stationary Stokes problem:   Fields   f\u2081::Function  f\u2082::Function  g::Function  ugD::Function  vgD::Function  usol::Function  vsol::Function  psol::Function  trueKnown::Bool   Constructors  StokesProblem(f\u2081,f\u2082,g,usol,vsol,psol)  StokesProblem(f\u2081,f\u2082,g,ugD,vgD)", 
            "title": "Problem Type"
        }, 
        {
            "location": "/man/stokesProblem/#example-problems", 
            "text": "#  DifferentialEquations.dirichletzeroStokesExample     Function .  Example problme for solving the trivial stationary Stokes equation.  #  DifferentialEquations.homogeneousStokesExample     Function .  Example problem for a homogeneous stationary Stokes equation.", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/mesh/", 
            "text": "Meshes\n\n\n\n\nMesh Specification\n\n\nFinite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:\n\n\n\n\nRow \ni\n of node is an \n(x,y)\n (or \n(x,y,z)\n) pair which specifies the coordinates of the \ni\nth node.\n\n\nRow \nj\n of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.\n\n\n\n\nFor example, to know the \n(x,y)\n locations of the vertices of triangle \nj\n, we would see that \nnode[elem[j,i],:]\n are the \n(x,y)\n locations of the \ni\nth vertex for \ni=1,2,3\n.\n\n\nFor more information, please see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\n\n\nMesh Type\n\n\n#\n\n\nDifferentialEquations.FEMmesh\n \n \nType\n.\n\n\nFEMmesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\nbdNode\n: Vector of indices for the boundary nodes.\n\n\nfreeNode\n: Vector of indices for the free (non-Dirichlet bound) nodes.\n\n\nbdEdge\n: Indices of the edges in totalEdge which are on the boundary.\n\n\nisBdNode\n: Boolean which is true for nodes on the boundary.\n\n\nisBdElem\n: Boolean which is true for elements on the boundary.\n\n\nbdFlag\n: Flag which describes the type of boundary condition. 1=\n Dirichlet, 2=\nNeumann, 3=\nRobin.\n\n\ntotalEdge\n: Vector of the edges.\n\n\narea\n: Vector which is the area for each element.\n\n\nDirichlet\n: Indices for the nodes on the boundary which have a Dirichlet boundary condition.\n\n\nNeumann\n: Indices for the nodes on the boundary which have a Neumann boundary condition.\n\n\nRobin\n: Indices for the nodes on the boundary which have a Robin boundary condition.\n\n\nN::Int\n: The number of nodes.\n\n\nNT\n::Int: The number of triangles (elements).\n\n\n\u0394x\n: The spatial discretization size. If non-uniform, this is the average.\n\n\n\u0394t\n: The time discretization size. If adaptive, this is the initial.\n\n\nT\n::Number: The end time.\n\n\nnumIters\n::Int: The number of iterations to go from 0 to T using \u0394t.\n\n\n\u03bc\n: The CFL \u03bc stability parameter.\n\n\n\u03bd\n: The CFL \u03bd stability parameter.\n\n\nevolutionEq\n: True for a mesh which has non-trivial time components.\n\n\n\n\n#\n\n\nDifferentialEquations.SimpleMesh\n \n \nType\n.\n\n\nSimpleMesh\n\n\nHolds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see \nProgramming of Finite Element Methods by Long Chen\n.\n\n\nFields\n\n\n\n\nnode\n: The nodes in the (node,elem) structure.\n\n\nelem\n: The elements in the (node,elem) structure.\n\n\n\n\n#\n\n\nDifferentialEquations.Mesh\n \n \nType\n.\n\n\nMesh: An abstract type which holds a (node,elem) pair and other information for a mesh\n\n\n\n\nMesh Generation Functions\n\n\n#\n\n\nDifferentialEquations.findboundary\n \n \nFunction\n.\n\n\nfindboundary(elem,bdFlag=[])\n\n\nfindboundary(femMesh::FEMmesh,bdFlag=[])\n\n\nFinds elements which are on the boundary of the domain. If bdFlag is given, then those indices are added as nodes for a Dirichlet boundary condition (useful for creating cracks and other cutouts of domains).\n\n\nReturns\n\n\nbdNode = Vector of indices for bdNode. Using node[:,bdNode] returns boundary nodes.\n\n\nbdEdge = Vector of indices for boundary edges.\n\n\nisBdNode = Vector of booleans size N which donotes which are on the boundary\n\n\nisBdElem = Vector of booleans size NT which denotes which are on the boundary\n\n\n#\n\n\nDifferentialEquations.setboundary\n \n \nFunction\n.\n\n\nsetboundary(node::AbstractArray,elem::AbstractArray,bdType)\n\n\nsetboundary(femMesh::FEMmesh,bdType)\n\n\nTakes in the femMesh and creates an array bdFlag which denotes the boundary types. 1 stands for Dirichlet, 2 for Neumann, 3 for Robin.\n\n\n#\n\n\nDifferentialEquations.fem_squaremesh\n \n \nFunction\n.\n\n\nfem_squaremesh(square,h)\n\n\nReturns the grid in the iFEM form of the two arrays (node,elem)\n\n\n#\n\n\nDifferentialEquations.notime_squaremesh\n \n \nFunction\n.\n\n\nnotime_squaremesh(square,\u0394x,bdType)\n\n\nComputes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x,\nDirichlet\n)\n\n\n\n\n#\n\n\nDifferentialEquations.parabolic_squaremesh\n \n \nFunction\n.\n\n\nparabolic_squaremesh(square,\u0394x,\u0394t,T,bdType)\n\n\nComputes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,\nDirichlet\n)\n\n\n\n\n\n\nExample Meshes\n\n\n#\n\n\nDifferentialEquations.meshExample_bunny\n \n \nFunction\n.\n\n\nmeshExample_bunny() : Returns a 3D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_flowpastcylindermesh\n \n \nFunction\n.\n\n\nmeshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_lakemesh\n \n \nFunction\n.\n\n\nmeshExample_lakemesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapemesh\n \n \nFunction\n.\n\n\nmeshExample_Lshapemesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_Lshapeunstructure\n \n \nFunction\n.\n\n\nmeshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_oilpump\n \n \nFunction\n.\n\n\nmeshExample_oilpump() : Returns a 3D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_wavymesh\n \n \nFunction\n.\n\n\nmeshExample_wavymesh() : Returns a 2D SimpleMesh.\n\n\n#\n\n\nDifferentialEquations.meshExample_wavyperturbmesh\n \n \nFunction\n.\n\n\nmeshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.\n\n\n\n\nPlot Functions\n\n\nThe plot functionality is provided by a Plots.jl recipe. What is plotted is a \"trisurf\" of the mesh. To plot a mesh, simply use:\n\n\nplot(mesh::Mesh)\n\n\n\n\nAll of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#meshes", 
            "text": "", 
            "title": "Meshes"
        }, 
        {
            "location": "/man/mesh/#mesh-specification", 
            "text": "Finite element meshes are specified in the (node,elem) structure due to Long Chen. For the standard elements used in this package, we describe a geometric figure by a triangulation. The nodes are the vertices of the triangle and the elements are the triangles themselves. These are encoded as follows:   Row  i  of node is an  (x,y)  (or  (x,y,z) ) pair which specifies the coordinates of the  i th node.  Row  j  of elem are the indices of the nodes which make the triangle. Thus in 2D each row has three numbers.   For example, to know the  (x,y)  locations of the vertices of triangle  j , we would see that  node[elem[j,i],:]  are the  (x,y)  locations of the  i th vertex for  i=1,2,3 .  For more information, please see  Programming of Finite Element Methods by Long Chen .", 
            "title": "Mesh Specification"
        }, 
        {
            "location": "/man/mesh/#mesh-type", 
            "text": "#  DifferentialEquations.FEMmesh     Type .  FEMmesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see the mesh specification documentation.  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.  bdNode : Vector of indices for the boundary nodes.  freeNode : Vector of indices for the free (non-Dirichlet bound) nodes.  bdEdge : Indices of the edges in totalEdge which are on the boundary.  isBdNode : Boolean which is true for nodes on the boundary.  isBdElem : Boolean which is true for elements on the boundary.  bdFlag : Flag which describes the type of boundary condition. 1=  Dirichlet, 2= Neumann, 3= Robin.  totalEdge : Vector of the edges.  area : Vector which is the area for each element.  Dirichlet : Indices for the nodes on the boundary which have a Dirichlet boundary condition.  Neumann : Indices for the nodes on the boundary which have a Neumann boundary condition.  Robin : Indices for the nodes on the boundary which have a Robin boundary condition.  N::Int : The number of nodes.  NT ::Int: The number of triangles (elements).  \u0394x : The spatial discretization size. If non-uniform, this is the average.  \u0394t : The time discretization size. If adaptive, this is the initial.  T ::Number: The end time.  numIters ::Int: The number of iterations to go from 0 to T using \u0394t.  \u03bc : The CFL \u03bc stability parameter.  \u03bd : The CFL \u03bd stability parameter.  evolutionEq : True for a mesh which has non-trivial time components.   #  DifferentialEquations.SimpleMesh     Type .  SimpleMesh  Holds the information describing a finite element mesh. For information on how (node,elem) can be interpreted as a mesh describing a geometry, see  Programming of Finite Element Methods by Long Chen .  Fields   node : The nodes in the (node,elem) structure.  elem : The elements in the (node,elem) structure.   #  DifferentialEquations.Mesh     Type .  Mesh: An abstract type which holds a (node,elem) pair and other information for a mesh", 
            "title": "Mesh Type"
        }, 
        {
            "location": "/man/mesh/#mesh-generation-functions", 
            "text": "#  DifferentialEquations.findboundary     Function .  findboundary(elem,bdFlag=[])  findboundary(femMesh::FEMmesh,bdFlag=[])  Finds elements which are on the boundary of the domain. If bdFlag is given, then those indices are added as nodes for a Dirichlet boundary condition (useful for creating cracks and other cutouts of domains).  Returns  bdNode = Vector of indices for bdNode. Using node[:,bdNode] returns boundary nodes.  bdEdge = Vector of indices for boundary edges.  isBdNode = Vector of booleans size N which donotes which are on the boundary  isBdElem = Vector of booleans size NT which denotes which are on the boundary  #  DifferentialEquations.setboundary     Function .  setboundary(node::AbstractArray,elem::AbstractArray,bdType)  setboundary(femMesh::FEMmesh,bdType)  Takes in the femMesh and creates an array bdFlag which denotes the boundary types. 1 stands for Dirichlet, 2 for Neumann, 3 for Robin.  #  DifferentialEquations.fem_squaremesh     Function .  fem_squaremesh(square,h)  Returns the grid in the iFEM form of the two arrays (node,elem)  #  DifferentialEquations.notime_squaremesh     Function .  notime_squaremesh(square,\u0394x,bdType)  Computes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.", 
            "title": "Mesh Generation Functions"
        }, 
        {
            "location": "/man/mesh/#example", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x, Dirichlet )  #  DifferentialEquations.parabolic_squaremesh     Function .  parabolic_squaremesh(square,\u0394x,\u0394t,T,bdType)  Computes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example_1", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T, Dirichlet )", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example-meshes", 
            "text": "#  DifferentialEquations.meshExample_bunny     Function .  meshExample_bunny() : Returns a 3D SimpleMesh.  #  DifferentialEquations.meshExample_flowpastcylindermesh     Function .  meshExample_flowpastcylindermesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_lakemesh     Function .  meshExample_lakemesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_Lshapemesh     Function .  meshExample_Lshapemesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_Lshapeunstructure     Function .  meshExample_Lshapeunstructure() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_oilpump     Function .  meshExample_oilpump() : Returns a 3D SimpleMesh.  #  DifferentialEquations.meshExample_wavymesh     Function .  meshExample_wavymesh() : Returns a 2D SimpleMesh.  #  DifferentialEquations.meshExample_wavyperturbmesh     Function .  meshExample_wavyperturbmesh() : Returns a 3D SimpleMesh.", 
            "title": "Example Meshes"
        }, 
        {
            "location": "/man/mesh/#plot-functions", 
            "text": "The plot functionality is provided by a Plots.jl recipe. What is plotted is a \"trisurf\" of the mesh. To plot a mesh, simply use:  plot(mesh::Mesh)  All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/solvers/", 
            "text": "Information on Solvers\n\n\n\n\nOrdinary Differential Equation Solvers\n\n\n\n\nODE\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nnothing\n\n\n\n\nODE Solver Extras\n\n\n#\n\n\nDifferentialEquations.ExplicitRK\n \n \nType\n.\n\n\nExplicitRK\n\n\nHolds a tableau which defines an explicit Runge-Kutta method.\n\n\n#\n\n\nDifferentialEquations.DEFAULT_TABLEAU\n \n \nConstant\n.\n\n\nDEFAULT_TABLEAU\n\n\nSets the default tableau for the ODE solver. Currently Dormand-Prince 4/5.\n\n\n#\n\n\nDifferentialEquations.constructCashKarp\n \n \nFunction\n.\n\n\nconstructCashKarp()\n\n\nConstructs the tableau object for the Cash-Karp Order 4/5 method.\n\n\n#\n\n\nDifferentialEquations.constructRalston\n \n \nFunction\n.\n\n\nconstructRalston()\n\n\nConstructs the tableau object for Ralston's Order 2 method.\n\n\n#\n\n\nDifferentialEquations.constructDormandPrince\n \n \nFunction\n.\n\n\nconstructDormandPrince()\n\n\nConstructs the tableau object for the Dormand-Prince Order 4/5 method.\n\n\n#\n\n\nDifferentialEquations.constructBogakiShampine\n \n \nFunction\n.\n\n\nconstructBogakiShampine()\n\n\nConstructs the tableau object for the Bogakai-Shampine Order 2/3 method.\n\n\n#\n\n\nDifferentialEquations.constructHuen\n \n \nFunction\n.\n\n\nconstructHuen()\n\n\nConstructs the tableau object for Huen's Order 2 method.\n\n\n#\n\n\nDifferentialEquations.constructRKF\n \n \nFunction\n.\n\n\nconstructRKF()\n\n\nConstructs the tableau object for the Runge-Kutta-Fuhlberg Order 4/5 method.\n\n\n#\n\n\nDifferentialEquations.constructRKF8\n \n \nFunction\n.\n\n\nconstructRKF8()\n\n\nConstructs the tableau object for the Runge-Kutta-Fuhlberg Order 7/8 method.\n\n\n\n\nStochastic Differential Equation Solvers\n\n\n\n\nSDE\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nnothing\n\n\n\n\nSDE Solver Extras\n\n\n#\n\n\nDifferentialEquations.monteCarloSim\n \n \nFunction\n.\n\n\nmonteCarloSim(\u0394t::Number,prob::SDEProblem)\n\n\nPerforms a parallel Monte-Carlo simulation to solve the SDE problem with \u0394t numMonte times. Returns a vector of solution objects.\n\n\nKeyword Arguments\n\n\n\n\nT - Final time. Default is 1.\n\n\nnumMonte - Number of Monte-Carlo simulations to run. Default is 10000\n\n\nfullSave - Denotes whether fullSave should be turned on in each run. Default is true.\n\n\nalg - Algorithm for solving the SDEs. Default is \"EM\"\n\n\n\n\n#\n\n\nDifferentialEquations.RosslerSRI\n \n \nType\n.\n\n\nRosslerSRI\n\n\nHolds the Butcher tableaus for a Rosser SRI method.\n\n\n#\n\n\nDifferentialEquations.RosslerSRA\n \n \nType\n.\n\n\nRosslerSRA\n\n\nHolds the Butcher tableaus for a Rosser SRA method.\n\n\n#\n\n\nDifferentialEquations.constructSRA1\n \n \nFunction\n.\n\n\nconstructSRA1()\n\n\nConstructs the taleau type for the SRA1 method.\n\n\n#\n\n\nDifferentialEquations.constructSRIW1\n \n \nFunction\n.\n\n\nconstructSRIW1()\n\n\nConstructs the tableau type for the SRIW1 method.\n\n\n#\n\n\nDifferentialEquations.checkSRAOrder\n \n \nFunction\n.\n\n\ncheckSRAOrder(RosslerSRI)\n\n\nDetermines whether the order conditions are met via the tableaus of the SRA method.\n\n\n#\n\n\nDifferentialEquations.checkSRIOrder\n \n \nFunction\n.\n\n\ncheckSRIOrder(RosslerSRI)\n\n\nDetermines whether the order conditions are met via the tableaus of the SRI method.\n\n\n\n\nFinite Difference Method Solvers\n\n\n\n\nStokes Equation\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nsolve(prob::StokesProblem,mesh::FDMMesh)\n\n\nSolves the given stationary Stokes problem on the given finite difference mesh.\n\n\nKeyword Arguments\n\n\n\n\nconverrors\n: Whether to calculate all of the errors along the convergence. Default is true.\n\n\nmaxiters\n: Maximum number of iterations before haulting. Default is 100.\n\n\nalg\n: The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".\n\n\nlevel\n: The number of levels in the Multigrid. Default is 2.\n\n\nsmoothSteps\n: The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.\n\n\ncoarseSteps\n: The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.\n\n\ngsiters\n: The number of Gauss-Seidel iterations to do at each step. Default is 20.\n\n\n\n\n\n\nFinite Element Method Solvers\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nFinite Element Poisson Equation Solver\n\n\nsolve(femMesh::FEMmesh,pdeProb::PoissonProblem)\n\n\nTakes in a definition for the heat equation \n-\u0394u = f\n on \nfemMesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic Poisson equation \n-\u0394u = f + \u03c3dW\n.\n\n\nKeyword Arguments\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\nDirect\n = Solves \nAx=b\n using ``\n\n\nCG\n = Conjugate-Gradient. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.\n\n\nGMRES\n = GMRES. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is not positive definite.\n\n\nsaveSteps\n = If \nfullSave=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nMethod\n.\n\n\nFinite Element Heat Equation Solver\n\n\nsolve(femMesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation \nu_t = \u0394u + f\n on \nfemMesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic heat equation \nu_t = \u0394u + f + \u03c3dW_t\n.\n\n\nKeyword Arguments\n\n\n\n\nalg\n = Solution algorithm. Default is Euler. The choices are:\n\n\nLinear     * Euler (Explicit)     * Implicit Euler (Implicit)     * Crank-Nicholson (Implicit)\n\n\nNonlinear     * Euler (Explicit)     * Implicit Euler (Nonlinear Solve)     * Crank-Nicholson (Nonlinear Solve)     * Semi-Implicit Euler (Implicit)     * Semi-Implicit Crank-Nicholson (Implicit)\n\n\n\n\nExplicit algorithms only require solving matrix multiplications \nAu\n. Implicit algorithms require solving the linear equation \nAx=b\n where \nx\n is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\nDirect\n = Solves using `` (no factorization). Not recommended.\n\n\nCholesky\n = Cholsky decomposition. Only stable of \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.     This means that this works best when \u0394t is small. When applicable, this is the fastest.\n\n\nLU\n = LU-Decomposition. A good mix between fast and stable.\n\n\nQR\n = QR-Decomposition. Less numerical roundoff error than \nLU\n, but slightly slower.\n\n\nSVD\n = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.\n\n\nCG\n = Conjugate-Gradient. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.\n\n\nGMRES\n = GMRES. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is not positive definite.\n\n\nfullSave\n = Makes the algorithm save the output at every \nsaveSteps\n timesteps. By default fullSave is false.\n\n\nsaveSteps\n = If \nfullSave=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.", 
            "title": "Information on Solvers"
        }, 
        {
            "location": "/man/solvers/#information-on-solvers", 
            "text": "", 
            "title": "Information on Solvers"
        }, 
        {
            "location": "/man/solvers/#ordinary-differential-equation-solvers", 
            "text": "", 
            "title": "Ordinary Differential Equation Solvers"
        }, 
        {
            "location": "/man/solvers/#ode", 
            "text": "#  DifferentialEquations.solve     Method .  nothing", 
            "title": "ODE"
        }, 
        {
            "location": "/man/solvers/#ode-solver-extras", 
            "text": "#  DifferentialEquations.ExplicitRK     Type .  ExplicitRK  Holds a tableau which defines an explicit Runge-Kutta method.  #  DifferentialEquations.DEFAULT_TABLEAU     Constant .  DEFAULT_TABLEAU  Sets the default tableau for the ODE solver. Currently Dormand-Prince 4/5.  #  DifferentialEquations.constructCashKarp     Function .  constructCashKarp()  Constructs the tableau object for the Cash-Karp Order 4/5 method.  #  DifferentialEquations.constructRalston     Function .  constructRalston()  Constructs the tableau object for Ralston's Order 2 method.  #  DifferentialEquations.constructDormandPrince     Function .  constructDormandPrince()  Constructs the tableau object for the Dormand-Prince Order 4/5 method.  #  DifferentialEquations.constructBogakiShampine     Function .  constructBogakiShampine()  Constructs the tableau object for the Bogakai-Shampine Order 2/3 method.  #  DifferentialEquations.constructHuen     Function .  constructHuen()  Constructs the tableau object for Huen's Order 2 method.  #  DifferentialEquations.constructRKF     Function .  constructRKF()  Constructs the tableau object for the Runge-Kutta-Fuhlberg Order 4/5 method.  #  DifferentialEquations.constructRKF8     Function .  constructRKF8()  Constructs the tableau object for the Runge-Kutta-Fuhlberg Order 7/8 method.", 
            "title": "ODE Solver Extras"
        }, 
        {
            "location": "/man/solvers/#stochastic-differential-equation-solvers", 
            "text": "", 
            "title": "Stochastic Differential Equation Solvers"
        }, 
        {
            "location": "/man/solvers/#sde", 
            "text": "#  DifferentialEquations.solve     Method .  nothing", 
            "title": "SDE"
        }, 
        {
            "location": "/man/solvers/#sde-solver-extras", 
            "text": "#  DifferentialEquations.monteCarloSim     Function .  monteCarloSim(\u0394t::Number,prob::SDEProblem)  Performs a parallel Monte-Carlo simulation to solve the SDE problem with \u0394t numMonte times. Returns a vector of solution objects.  Keyword Arguments   T - Final time. Default is 1.  numMonte - Number of Monte-Carlo simulations to run. Default is 10000  fullSave - Denotes whether fullSave should be turned on in each run. Default is true.  alg - Algorithm for solving the SDEs. Default is \"EM\"   #  DifferentialEquations.RosslerSRI     Type .  RosslerSRI  Holds the Butcher tableaus for a Rosser SRI method.  #  DifferentialEquations.RosslerSRA     Type .  RosslerSRA  Holds the Butcher tableaus for a Rosser SRA method.  #  DifferentialEquations.constructSRA1     Function .  constructSRA1()  Constructs the taleau type for the SRA1 method.  #  DifferentialEquations.constructSRIW1     Function .  constructSRIW1()  Constructs the tableau type for the SRIW1 method.  #  DifferentialEquations.checkSRAOrder     Function .  checkSRAOrder(RosslerSRI)  Determines whether the order conditions are met via the tableaus of the SRA method.  #  DifferentialEquations.checkSRIOrder     Function .  checkSRIOrder(RosslerSRI)  Determines whether the order conditions are met via the tableaus of the SRI method.", 
            "title": "SDE Solver Extras"
        }, 
        {
            "location": "/man/solvers/#finite-difference-method-solvers", 
            "text": "", 
            "title": "Finite Difference Method Solvers"
        }, 
        {
            "location": "/man/solvers/#stokes-equation", 
            "text": "#  DifferentialEquations.solve     Method .  solve(prob::StokesProblem,mesh::FDMMesh)  Solves the given stationary Stokes problem on the given finite difference mesh.  Keyword Arguments   converrors : Whether to calculate all of the errors along the convergence. Default is true.  maxiters : Maximum number of iterations before haulting. Default is 100.  alg : The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".  level : The number of levels in the Multigrid. Default is 2.  smoothSteps : The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.  coarseSteps : The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.  gsiters : The number of Gauss-Seidel iterations to do at each step. Default is 20.", 
            "title": "Stokes Equation"
        }, 
        {
            "location": "/man/solvers/#finite-element-method-solvers", 
            "text": "#  DifferentialEquations.solve     Method .  Finite Element Poisson Equation Solver  solve(femMesh::FEMmesh,pdeProb::PoissonProblem)  Takes in a definition for the heat equation  -\u0394u = f  on  femMesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic Poisson equation  -\u0394u = f + \u03c3dW .  Keyword Arguments   solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:  Direct  = Solves  Ax=b  using ``  CG  = Conjugate-Gradient. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.  GMRES  = GMRES. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is not positive definite.  saveSteps  = If  fullSave=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.   #  DifferentialEquations.solve     Method .  Finite Element Heat Equation Solver  solve(femMesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation  u_t = \u0394u + f  on  femMesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic heat equation  u_t = \u0394u + f + \u03c3dW_t .  Keyword Arguments   alg  = Solution algorithm. Default is Euler. The choices are:  Linear     * Euler (Explicit)     * Implicit Euler (Implicit)     * Crank-Nicholson (Implicit)  Nonlinear     * Euler (Explicit)     * Implicit Euler (Nonlinear Solve)     * Crank-Nicholson (Nonlinear Solve)     * Semi-Implicit Euler (Implicit)     * Semi-Implicit Crank-Nicholson (Implicit)   Explicit algorithms only require solving matrix multiplications  Au . Implicit algorithms require solving the linear equation  Ax=b  where  x  is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).   solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:  Direct  = Solves using `` (no factorization). Not recommended.  Cholesky  = Cholsky decomposition. Only stable of  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.     This means that this works best when \u0394t is small. When applicable, this is the fastest.  LU  = LU-Decomposition. A good mix between fast and stable.  QR  = QR-Decomposition. Less numerical roundoff error than  LU , but slightly slower.  SVD  = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.  CG  = Conjugate-Gradient. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.  GMRES  = GMRES. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is not positive definite.  fullSave  = Makes the algorithm save the output at every  saveSteps  timesteps. By default fullSave is false.  saveSteps  = If  fullSave=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.", 
            "title": "Finite Element Method Solvers"
        }, 
        {
            "location": "/man/solution/", 
            "text": "The Solution Type\n\n\nEach solver has an appropriate solution type. The solution type holds all of the information about the problem which was solved an its solution. If you enabled \nfullSave=true\n, then the solver also includes a time-course of the solution captured at every \nsaveSteps\n steps.\n\n\nThe solution type has a lot of built in functionality to help analysis. Plotting functionality is provided for each solution type. To plot the solution, simply use\n\n\nplot(sol)\n\n\n\n\nThe plotting function is implemented as a recipe to Plots.jl and as such receives all of the features of a Plots.jl plot.\n\n\nAnother feature is the \nConvergenceSimulation\ns.One can automatically have DifferentialEquations.jl perform the error analysis by passing a \nConvergenceSimulation\n a vector of solutions, or using one of the provided \ntestConvergence\n functions. These will give order of convergence estimates and provide plotting functionality.\n\n\n\n\nSolution Types\n\n\n#\n\n\nDifferentialEquations.FEMSolution\n \n \nType\n.\n\n\nFEMSolution\n\n\nHolds the data for the solution to a finite element problem.\n\n\nFields\n\n\n\n\nfemMesh::FEMmesh\n: The finite element mesh the problem was solved on.\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueKnown::Bool\n: Boolean flag for if the true solution is given.\n\n\nuTrue::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\nappxTrue::Bool\n: Boolean flag for if uTrue was an approximation.\n\n\nuFull\n::AbstractArrayOrVoid\n: u over time. Only saved if\nfullSave=true` is specified in the solver.\n\n\ntFull::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nfullSave=true\n is specified in the solver.\n\n\nprob::DEProblem\n: Holds the problem object used to define the problem.\n\n\nfullSave::Bool\n: True if solver saved the extra timepoints.\n\n\n\n\n#\n\n\nDifferentialEquations.DESolution\n \n \nType\n.\n\n\nPdeSolution: Wrapper for the objects obtained from a solver\n\n\n#\n\n\nDifferentialEquations.SDESolution\n \n \nType\n.\n\n\nSDESolution\n\n\nHolds the data for the solution to a SDE problem.\n\n\nFields\n\n\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueKnown::Bool\n: Boolean flag for if the true solution is given.\n\n\nuTrue::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\nuFull\n::AbstractArrayOrVoid\n: u over time. Only saved if\nfullSave=true` is specified in the solver.\n\n\ntFull::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nfullSave=true\n is specified in the solver.\n\n\nWFull\n: All of the W's in the solution. Only saved if \nfullSave=true\n is specified in the solver.\n\n\nsolFull\n: If \nfullSave=true\n, saves the solution at each save point.\n\n\nprob::DEProblem\n: Holds the problem object used to define the problem.\n\n\nfullSave::Bool\n: True if solver saved the extra timepoints.\n\n\nappxTrue::Bool\n: Boolean flag for if uTrue was an approximation.\n\n\n\n\n#\n\n\nDifferentialEquations.ODESolution\n \n \nType\n.\n\n\nODESolution\n\n\nHolds the data for the solution to an ODE problem.\n\n\nFields\n\n\n\n\nu::Array{Float64}\n: The solution (at the final timepoint)\n\n\ntrueKnown::Bool\n: Boolean flag for if the true solution is given.\n\n\nuTrue::AbstractArrayOrVoid\n: The true solution at the final timepoint.\n\n\nerrors\n: A dictionary of the error calculations.\n\n\nuFull\n::AbstractArrayOrVoid\n: u over time. Only saved if\nfullSave=true` is specified in the solver.\n\n\ntFull::AbstractArrayOrVoid\n: All the t's in the solution. Only saved if \nfullSave=true\n is specified in the solver.\n\n\nsolFull\n: If \nfullSave=true\n, saves the solution at each timestep.\n\n\nprob::DEProblem\n: Holds the problem object used to define the problem.\n\n\nfullSave::Bool\n: True if solver saved the extra timepoints.\n\n\nappxTrue::Bool\n: Boolean flag for if uTrue was an approximation.\n\n\n\n\n#\n\n\nDifferentialEquations.StokesSolution\n \n \nType\n.\n\n\nStokesSolution\n\n\nHolds the data for the solution to a Stokes problem.\n\n\nFields\n\n\n\n\nu\n\n\nv\n\n\np\n\n\nuTrue\n\n\nvTrue\n\n\npTrue\n\n\nmesh\n\n\ntrueKnown\n\n\nerrors\n\n\nconverrors\n\n\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.appxTrue!\n \n \nFunction\n.\n\n\nappxTrue!(res,res2)\n\n\nAdds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution\n\n\n#\n\n\nDifferentialEquations.FEMSolutionTS\n \n \nFunction\n.\n\n\nS = FEMSolutionTS(uFull::GrowableArray,numVars::Int) S[i][j] =\n Variable i at time j.", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#the-solution-type", 
            "text": "Each solver has an appropriate solution type. The solution type holds all of the information about the problem which was solved an its solution. If you enabled  fullSave=true , then the solver also includes a time-course of the solution captured at every  saveSteps  steps.  The solution type has a lot of built in functionality to help analysis. Plotting functionality is provided for each solution type. To plot the solution, simply use  plot(sol)  The plotting function is implemented as a recipe to Plots.jl and as such receives all of the features of a Plots.jl plot.  Another feature is the  ConvergenceSimulation s.One can automatically have DifferentialEquations.jl perform the error analysis by passing a  ConvergenceSimulation  a vector of solutions, or using one of the provided  testConvergence  functions. These will give order of convergence estimates and provide plotting functionality.", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#solution-types", 
            "text": "#  DifferentialEquations.FEMSolution     Type .  FEMSolution  Holds the data for the solution to a finite element problem.  Fields   femMesh::FEMmesh : The finite element mesh the problem was solved on.  u::Array{Float64} : The solution (at the final timepoint)  trueKnown::Bool : Boolean flag for if the true solution is given.  uTrue::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  appxTrue::Bool : Boolean flag for if uTrue was an approximation.  uFull ::AbstractArrayOrVoid : u over time. Only saved if fullSave=true` is specified in the solver.  tFull::AbstractArrayOrVoid : All the t's in the solution. Only saved if  fullSave=true  is specified in the solver.  prob::DEProblem : Holds the problem object used to define the problem.  fullSave::Bool : True if solver saved the extra timepoints.   #  DifferentialEquations.DESolution     Type .  PdeSolution: Wrapper for the objects obtained from a solver  #  DifferentialEquations.SDESolution     Type .  SDESolution  Holds the data for the solution to a SDE problem.  Fields   u::Array{Float64} : The solution (at the final timepoint)  trueKnown::Bool : Boolean flag for if the true solution is given.  uTrue::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  uFull ::AbstractArrayOrVoid : u over time. Only saved if fullSave=true` is specified in the solver.  tFull::AbstractArrayOrVoid : All the t's in the solution. Only saved if  fullSave=true  is specified in the solver.  WFull : All of the W's in the solution. Only saved if  fullSave=true  is specified in the solver.  solFull : If  fullSave=true , saves the solution at each save point.  prob::DEProblem : Holds the problem object used to define the problem.  fullSave::Bool : True if solver saved the extra timepoints.  appxTrue::Bool : Boolean flag for if uTrue was an approximation.   #  DifferentialEquations.ODESolution     Type .  ODESolution  Holds the data for the solution to an ODE problem.  Fields   u::Array{Float64} : The solution (at the final timepoint)  trueKnown::Bool : Boolean flag for if the true solution is given.  uTrue::AbstractArrayOrVoid : The true solution at the final timepoint.  errors : A dictionary of the error calculations.  uFull ::AbstractArrayOrVoid : u over time. Only saved if fullSave=true` is specified in the solver.  tFull::AbstractArrayOrVoid : All the t's in the solution. Only saved if  fullSave=true  is specified in the solver.  solFull : If  fullSave=true , saves the solution at each timestep.  prob::DEProblem : Holds the problem object used to define the problem.  fullSave::Bool : True if solver saved the extra timepoints.  appxTrue::Bool : Boolean flag for if uTrue was an approximation.   #  DifferentialEquations.StokesSolution     Type .  StokesSolution  Holds the data for the solution to a Stokes problem.  Fields   u  v  p  uTrue  vTrue  pTrue  mesh  trueKnown  errors  converrors", 
            "title": "Solution Types"
        }, 
        {
            "location": "/man/solution/#related-functions", 
            "text": "#  DifferentialEquations.appxTrue!     Function .  appxTrue!(res,res2)  Adds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution  #  DifferentialEquations.FEMSolutionTS     Function .  S = FEMSolutionTS(uFull::GrowableArray,numVars::Int) S[i][j] =  Variable i at time j.", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/plot/", 
            "text": "Plot Functions\n\n\n\n\nStandard Plots\n\n\nPlotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the \nplot(type)\n and the plotter will generate appropriate plots. If \nfullSave\n was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.\n\n\nA few extra arguments are provided addition to the Plots.jl keyword arguments. They are as follows:\n\n\n\n\nplottrue: Specifies whether the true solution (if known) should be plotted alongside the numerically approximated solution. Default is false.\n\n\n\n\n\n\nExtra Plot Functions\n\n\n#\n\n\nDifferentialEquations.animate\n \n \nFunction\n.\n\n\nanimate(sol::FEMSolution)\n\n\nPlots an animation of the solution. Requires \nfullSave=true\n was enabled in the solver.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#plot-functions", 
            "text": "", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#standard-plots", 
            "text": "Plotting functionality is provided by a recipe to Plots.jl. To use plot solutions, simply call the  plot(type)  and the plotter will generate appropriate plots. If  fullSave  was used, the plotters can generate animations of the solutions to evolution equations. Plots can be customized using all of the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.  A few extra arguments are provided addition to the Plots.jl keyword arguments. They are as follows:   plottrue: Specifies whether the true solution (if known) should be plotted alongside the numerically approximated solution. Default is false.", 
            "title": "Standard Plots"
        }, 
        {
            "location": "/man/plot/#extra-plot-functions", 
            "text": "#  DifferentialEquations.animate     Function .  animate(sol::FEMSolution)  Plots an animation of the solution. Requires  fullSave=true  was enabled in the solver.", 
            "title": "Extra Plot Functions"
        }, 
        {
            "location": "/man/convergence/", 
            "text": "Convergence Simulations\n\n\nThe convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.\n\n\nConvergenceSimulation\ns can either be created by passing the constructor the approrpiate solution array or by using one of the provided \ntestConvergence\n functions.\n\n\n\n\nThe ConvergenceSimulation Type\n\n\n#\n\n\nDifferentialEquations.ConvergenceSimulation\n \n \nType\n.\n\n\nConvergenceSimulation\n\n\nA type which holds the data from a convergence simulation.\n\n\nFields\n\n\n\n\nsolutions::Array{DESolution}\n: Holds all the PdeSolutions.\n\n\nerrors\n: Dictionary of the error calculations. Can contain:\n\n\nh1Errors\n: Vector of the H1 errors.\n\n\nl2Errors\n: Vector of the L2 errors.\n\n\nmaxErrors\n: Vector of the nodal maximum errors.\n\n\nnode2Errors\n: Vector of the nodal l2 errors.\n\n\nN\n: The number of simulations.\n\n\nauxData\n: Auxillary data of the convergence simluation. Entries can include:\n\n\n\u0394ts\n: The \u0394t's in the simulations.\n\n\n\u0394xs\n: The \u0394x's in the simulations.\n\n\n\u03bcs\n: The CFL \u03bc's in the simulations.\n\n\n\u03bds\n: The CFL \u03bd's in the simulations.\n\n\n\ud835\udcaaest\n: Dictionary of order estimates. Can contain:\n\n\nConvEst_h1\n: The H1 error order of convergence estimate for the convergence simulation.   Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1)\n\n\nConvEst_l2\n: The L2 error order of convergence estimate for the convergence simulation.   Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2)\n\n\nConvEst_max\n: The nodal maximum error order of convergence estimate for the convergence simulation.   Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max)\n\n\nConvEst_node2\n: The nodal l2 error order of convergence estimate for the convergence simulation.   Generated via \nlog2(error[i+1]/error[i])\n. Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)\n\n\nconvergenceAxis\n: The axis along which convergence is calculated. For example, if   we calculate the \u0394t convergence, convergenceAxis is the \u0394ts used in the calculation.\n\n\n\n\n\n\nPlot Functions\n\n\nThe plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:\n\n\nplot(sim::ConvergenceSimulation)\n\n\n\n\nAll of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.\n\n\n\n\nRelated Functions\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation\n\n\n#\n\n\nDifferentialEquations.conv_ests\n \n \nFunction\n.\n\n\nconv_ests(error::AbstractArray{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\n#\n\n\nDifferentialEquations.calc\ud835\udcaaestimates\n \n \nFunction\n.\n\n\nconv_ests(error::Vector{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\n#\n\n\nDifferentialEquations.testConvergence\n \n \nFunction\n.\n\n\ntestConvergence(\u0394xs::AbstractArray,prob::PoissonProblem)\n\n\nTests the convergence of the solver algorithm on the given Poisson problem with \u0394xs as given. Uses the square mesh [0,1]x[0,1].\n\n\nKeyword Arguments\n\n\n\n\nsolver\n: Which solver to use. Default is \"Direct\".\n\n\n\n\ntestConvergence(\u0394ts::AbstractArray,\u0394xs::AbstractArray,prob::HeatProblem,convergenceAxis)\n\n\nTests the convergence of the solver algorithm on the given Heat problem with the \u0394ts and \u0394xs as given. Uses the square mesh [0,1]x[0,1]. The convergence axis is the axis along which convergence is calculated. For example, when testing \u0394t convergence, \nconvergenceAxis = \u0394ts\n.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Defaults to 1\n\n\nalg\n: The algorithm to test. Default is \"Euler\".\n\n\n\n\ntestConvergence(\u0394ts::AbstractArray,prob::ODEProblem)\n\n\nTests the order of the time convergence of the given algorithm on the given problem solved over the given \u0394ts.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Default is 1\n\n\nfullSave\n: Denotes whether to save at every saveSteps steps. Default is true.\n\n\nsaveSteps\n: Denotes the steps to save at if \nfullSave=true\n. Default is 1\n\n\nalg\n: The algorithm to test. Defaults to \"Euler\".\n\n\ntableau\n: The tableau used for generic methods. Defaults to DEFAULT_TABLEAU.\n\n\n\n\ntestConvergence(\u0394ts::AbstractArray,prob::SDEProblem)\n\n\nTests the strong order time convergence of the given algorithm on the given problem solved over the given \u0394ts.\n\n\nKeyword Arguments\n\n\n\n\nT\n: The final time. Default is 1\n\n\nnumMonte\n: The number of simulations for each \u0394t. Default is 10000.\n\n\nfullSave\n: Denotes whether to save at every saveSteps steps. Default is true.\n\n\nsaveSteps\n: Denotes the steps to save at if \nfullSave=true\n. Default is 1\n\n\nalg\n: The algorithm to test. Defaults to \"EM\".", 
            "title": "Convergence Simuations"
        }, 
        {
            "location": "/man/convergence/#convergence-simulations", 
            "text": "The convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.  ConvergenceSimulation s can either be created by passing the constructor the approrpiate solution array or by using one of the provided  testConvergence  functions.", 
            "title": "Convergence Simulations"
        }, 
        {
            "location": "/man/convergence/#the-convergencesimulation-type", 
            "text": "#  DifferentialEquations.ConvergenceSimulation     Type .  ConvergenceSimulation  A type which holds the data from a convergence simulation.  Fields   solutions::Array{DESolution} : Holds all the PdeSolutions.  errors : Dictionary of the error calculations. Can contain:  h1Errors : Vector of the H1 errors.  l2Errors : Vector of the L2 errors.  maxErrors : Vector of the nodal maximum errors.  node2Errors : Vector of the nodal l2 errors.  N : The number of simulations.  auxData : Auxillary data of the convergence simluation. Entries can include:  \u0394ts : The \u0394t's in the simulations.  \u0394xs : The \u0394x's in the simulations.  \u03bcs : The CFL \u03bc's in the simulations.  \u03bds : The CFL \u03bd's in the simulations.  \ud835\udcaaest : Dictionary of order estimates. Can contain:  ConvEst_h1 : The H1 error order of convergence estimate for the convergence simulation.   Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_h1)  ConvEst_l2 : The L2 error order of convergence estimate for the convergence simulation.   Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_l2)  ConvEst_max : The nodal maximum error order of convergence estimate for the convergence simulation.   Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_max)  ConvEst_node2 : The nodal l2 error order of convergence estimate for the convergence simulation.   Generated via  log2(error[i+1]/error[i]) . Thus only valid if generated by halving/doubling   the \u0394t/\u0394x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)  convergenceAxis : The axis along which convergence is calculated. For example, if   we calculate the \u0394t convergence, convergenceAxis is the \u0394ts used in the calculation.", 
            "title": "The ConvergenceSimulation Type"
        }, 
        {
            "location": "/man/convergence/#plot-functions", 
            "text": "The plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:  plot(sim::ConvergenceSimulation)  All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/convergence/#related-functions", 
            "text": "#  Base.length     Method .  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation  #  DifferentialEquations.conv_ests     Function .  conv_ests(error::AbstractArray{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates  #  DifferentialEquations.calc\ud835\udcaaestimates     Function .  conv_ests(error::Vector{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates  #  DifferentialEquations.testConvergence     Function .  testConvergence(\u0394xs::AbstractArray,prob::PoissonProblem)  Tests the convergence of the solver algorithm on the given Poisson problem with \u0394xs as given. Uses the square mesh [0,1]x[0,1].  Keyword Arguments   solver : Which solver to use. Default is \"Direct\".   testConvergence(\u0394ts::AbstractArray,\u0394xs::AbstractArray,prob::HeatProblem,convergenceAxis)  Tests the convergence of the solver algorithm on the given Heat problem with the \u0394ts and \u0394xs as given. Uses the square mesh [0,1]x[0,1]. The convergence axis is the axis along which convergence is calculated. For example, when testing \u0394t convergence,  convergenceAxis = \u0394ts .  Keyword Arguments   T : The final time. Defaults to 1  alg : The algorithm to test. Default is \"Euler\".   testConvergence(\u0394ts::AbstractArray,prob::ODEProblem)  Tests the order of the time convergence of the given algorithm on the given problem solved over the given \u0394ts.  Keyword Arguments   T : The final time. Default is 1  fullSave : Denotes whether to save at every saveSteps steps. Default is true.  saveSteps : Denotes the steps to save at if  fullSave=true . Default is 1  alg : The algorithm to test. Defaults to \"Euler\".  tableau : The tableau used for generic methods. Defaults to DEFAULT_TABLEAU.   testConvergence(\u0394ts::AbstractArray,prob::SDEProblem)  Tests the strong order time convergence of the given algorithm on the given problem solved over the given \u0394ts.  Keyword Arguments   T : The final time. Default is 1  numMonte : The number of simulations for each \u0394t. Default is 10000.  fullSave : Denotes whether to save at every saveSteps steps. Default is true.  saveSteps : Denotes the steps to save at if  fullSave=true . Default is 1  alg : The algorithm to test. Defaults to \"EM\".", 
            "title": "Related Functions"
        }, 
        {
            "location": "/internals/femTools/", 
            "text": "Internal Finite Element Tools\n\n\n\n\nGeneral\n\n\n#\n\n\nDifferentialEquations\n \n \nModule\n.\n\n\nDifferentialEquations\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see \nODE.jl\n\n\nThis package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.\n\n\n\n\nMesh Tools\n\n\n#\n\n\nDifferentialEquations.meshgrid\n \n \nFunction\n.\n\n\nmeshgrid(vx,vy,vz)\n\n\nComputes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.\n\n\nmeshgrid(vx,vy)\n\n\nComputes an (x,y)-grid from the vectors (vx,vy). For more information, see the MATLAB documentation.\n\n\nmeshgrid(vx)\n\n\nComputes an (x,y)-grid from the vectors (vx,vx). For more information, see the MATLAB documentation.\n\n\n#\n\n\nDifferentialEquations.CFL\u03bd\n \n \nFunction\n.\n\n\nCFL\u03bd(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bd= \u0394t/\u0394x\n\n\n#\n\n\nDifferentialEquations.CFL\u03bc\n \n \nFunction\n.\n\n\nCFL\u03bc(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)\n\n\n\n\nSolver Tools\n\n\n#\n\n\nDifferentialEquations.\u2207basis\n \n \nFunction\n.\n\n\n\u2207basis(node,elem)\n\n\nReturns the \u2207u of the barycentric basis elements.\n\n\n#\n\n\nDifferentialEquations.quadfbasis\n \n \nFunction\n.\n\n\nquadfbasis(f,gD,gN,A,u,node,elem,area,bdNode,mid,N,Dirichlet,Neumann,isLinear,numVars;gNquad\ud835\udcaa=2)\n\n\nPerforms the order 2 quadrature to calculate the vector from the term \nf,v\n for linear elements.\n\n\n#\n\n\nDifferentialEquations.quadpts\n \n \nFunction\n.\n\n\nquadpts(\ud835\udcaa)\n\n\nReturns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.\n\n\nReference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.\n\n\n#\n\n\nDifferentialEquations.quadpts1\n \n \nFunction\n.\n\n\nquadpts1(\ud835\udcaa)\n\n\nReferences: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/\n\n\n#\n\n\nDifferentialEquations.accumarray\n \n \nFunction\n.\n\n\naccumarray(subs, val, sz=(maximum(subs),))\n\n\nSee MATLAB's documentation for more details.\n\n\n#\n\n\nDifferentialEquations.assemblematrix\n \n \nFunction\n.\n\n\nassemblematrix(node,elem;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nassemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\n#\n\n\nDifferentialEquations.\u2207u\n \n \nFunction\n.\n\n\n\u2207u(node,elem,u,D\u03bb=[])\n\n\nEstimates \u2207u of u on the mesh (node,elem)\n\n\n\n\nError Tools\n\n\n#\n\n\nDifferentialEquations.getH1error\n \n \nFunction\n.\n\n\nfunction getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])\n\n\ngetH1error(femMesh::FEMmesh,Du,u)\n\n\nEstimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.\n\n\n#\n\n\nDifferentialEquations.getL2error\n \n \nFunction\n.\n\n\ngetL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])\n\n\ngetL2error(femMesh::FEMmesh,sol,u)\n\n\nEstimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/femTools/#internal-finite-element-tools", 
            "text": "", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/femTools/#general", 
            "text": "#  DifferentialEquations     Module .", 
            "title": "General"
        }, 
        {
            "location": "/internals/femTools/#differentialequations", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see  ODE.jl  This package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.", 
            "title": "DifferentialEquations"
        }, 
        {
            "location": "/internals/femTools/#mesh-tools", 
            "text": "#  DifferentialEquations.meshgrid     Function .  meshgrid(vx,vy,vz)  Computes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.  meshgrid(vx,vy)  Computes an (x,y)-grid from the vectors (vx,vy). For more information, see the MATLAB documentation.  meshgrid(vx)  Computes an (x,y)-grid from the vectors (vx,vx). For more information, see the MATLAB documentation.  #  DifferentialEquations.CFL\u03bd     Function .  CFL\u03bd(\u0394t,\u0394x)  Computes the CFL-condition \u03bd= \u0394t/\u0394x  #  DifferentialEquations.CFL\u03bc     Function .  CFL\u03bc(\u0394t,\u0394x)  Computes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)", 
            "title": "Mesh Tools"
        }, 
        {
            "location": "/internals/femTools/#solver-tools", 
            "text": "#  DifferentialEquations.\u2207basis     Function .  \u2207basis(node,elem)  Returns the \u2207u of the barycentric basis elements.  #  DifferentialEquations.quadfbasis     Function .  quadfbasis(f,gD,gN,A,u,node,elem,area,bdNode,mid,N,Dirichlet,Neumann,isLinear,numVars;gNquad\ud835\udcaa=2)  Performs the order 2 quadrature to calculate the vector from the term  f,v  for linear elements.  #  DifferentialEquations.quadpts     Function .  quadpts(\ud835\udcaa)  Returns the quadrature points and \u03c9's for and \ud835\udcaa ### quadrature in 2D.  Reference: David Dunavant. High degree efficient symmetrical Gaussian quadrature rules for the triangle. International journal for numerical methods in engineering. 21(6):1129\u20131148, 1985.  #  DifferentialEquations.quadpts1     Function .  quadpts1(\ud835\udcaa)  References: Pavel Holoborodko: http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/  #  DifferentialEquations.accumarray     Function .  accumarray(subs, val, sz=(maximum(subs),))  See MATLAB's documentation for more details.  #  DifferentialEquations.assemblematrix     Function .  assemblematrix(node,elem;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  assemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  #  DifferentialEquations.\u2207u     Function .  \u2207u(node,elem,u,D\u03bb=[])  Estimates \u2207u of u on the mesh (node,elem)", 
            "title": "Solver Tools"
        }, 
        {
            "location": "/internals/femTools/#error-tools", 
            "text": "#  DifferentialEquations.getH1error     Function .  function getH1error(node,elem,Du,uh,K=[],quad\ud835\udcaa=[])  getH1error(femMesh::FEMmesh,Du,u)  Estimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified. If K is specified then it is the diffusion coefficient matrix.  #  DifferentialEquations.getL2error     Function .  getL2error(node,elem,uexact,uh,quad\ud835\udcaa=[])  getL2error(femMesh::FEMmesh,sol,u)  Estimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature \ud835\udcaa unless specified.", 
            "title": "Error Tools"
        }, 
        {
            "location": "/internals/extras/", 
            "text": "Extra Functions\n\n\n#\n\n\nDifferentialEquations.getNoise\n \n \nFunction\n.\n\n\ngetNoise(N,node,elem;noiseType=\"White\")\n\n\nReturns a random vector corresponding to the noise type which was chosen.\n\n\n#\n\n\nDifferentialEquations.numparameters\n \n \nFunction\n.\n\n\nnumparameters(f)\n\n\nReturns the number of parameters of \nf\n for the method which has the most parameters.\n\n\n\n\nMaking Build Work\n\n\n#\n\n\nDifferentialEquations.solve\n \n \nFunction\n.\n\n\nsolve(prob::ODEProblem,\u0394t,T)\n\n\nSolves the ODE defined by prob with initial \u0394t on the time interval [0,T].\n\n\nKeyword Arguments\n\n\n\n\nfullSave: Saves the result at every saveSteps steps. Default is false. saveSteps: If fullSave is true, then the output is saved every saveSteps steps.\n\n\nalg: String which defines the solver algorithm. Defult is \"RK4\". Possibilities are:\n\n\n\"Euler\" - The canonical forward Euler method.\n\n\n\"Midpoint\" - The second order midpoint method.\n\n\n\"RK4\" - The canonical Runge-Kutta Order 4 method.\n\n\n\"ExplicitRK\" - A general Runge-Kutta solver which takes in a tableau. Can be adaptive.\n\n\n\"ImplicitEuler\" - A 1st order implicit solver. Unconditionally stable.\n\n\n\"Trapezoid\" - A second order unconditionally stable implicit solver. Good for highly stiff.\n\n\n\"Rosenbrock23\" - A fast solver which is good for stiff equations.\n\n\ntableau - Takes in an object which defines a tableau. Default is Dormand-Prince 4/5.\n\n\nadaptive - Turns on adaptive timestepping for appropriate methods. Default is false.\n\n\ntol - The error tolerance of the adaptive method. Default is 1e-4.\n\n\n\u03b3 - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.\n\n\nqmax - Defines the maximum value possible for the adaptive q. Default is 10.\n\n\n\n\nsolve(prob::SDEProblem,tspan=[0,1];\u0394t=0)\n\n\nSolves the SDE as defined by prob with initial \u0394t on the time interval tspan. If not given, tspan defaults to [0,1]. If\n\n\nKeyword Arguments\n\n\n\n\nfullSave: Saves the result at every saveSteps steps. Default is false. saveSteps: If fullSave is true, then the output is saved every saveSteps steps.\n\n\nalg: String which defines the solver algorithm. Defult is \"SRI\". Possibilities are:\n\n\n\"EM\"- The Euler-Maruyama method.\n\n\n\"RKMil\" - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.\n\n\n\"SRA\" - The strong Order 1.5 method for additive SDEs due to Rossler.\n\n\n\"SRI\" - The strong Order 1.5 method for diagonal/scalar SDEs due to Rossler. Most efficient.\n\n\n\n\nsolve(prob::StokesProblem,mesh::FDMMesh)\n\n\nSolves the given stationary Stokes problem on the given finite difference mesh.\n\n\nKeyword Arguments\n\n\n\n\nconverrors\n: Whether to calculate all of the errors along the convergence. Default is true.\n\n\nmaxiters\n: Maximum number of iterations before haulting. Default is 100.\n\n\nalg\n: The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".\n\n\nlevel\n: The number of levels in the Multigrid. Default is 2.\n\n\nsmoothSteps\n: The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.\n\n\ncoarseSteps\n: The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.\n\n\ngsiters\n: The number of Gauss-Seidel iterations to do at each step. Default is 20.\n\n\n\n\nFinite Element Heat Equation Solver\n\n\nsolve(femMesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation \nu_t = \u0394u + f\n on \nfemMesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic heat equation \nu_t = \u0394u + f + \u03c3dW_t\n.\n\n\nKeyword Arguments\n\n\n\n\nalg\n = Solution algorithm. Default is Euler. The choices are:\n\n\nLinear     * Euler (Explicit)     * Implicit Euler (Implicit)     * Crank-Nicholson (Implicit)\n\n\nNonlinear     * Euler (Explicit)     * Implicit Euler (Nonlinear Solve)     * Crank-Nicholson (Nonlinear Solve)     * Semi-Implicit Euler (Implicit)     * Semi-Implicit Crank-Nicholson (Implicit)\n\n\n\n\nExplicit algorithms only require solving matrix multiplications \nAu\n. Implicit algorithms require solving the linear equation \nAx=b\n where \nx\n is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\nDirect\n = Solves using `` (no factorization). Not recommended.\n\n\nCholesky\n = Cholsky decomposition. Only stable of \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.     This means that this works best when \u0394t is small. When applicable, this is the fastest.\n\n\nLU\n = LU-Decomposition. A good mix between fast and stable.\n\n\nQR\n = QR-Decomposition. Less numerical roundoff error than \nLU\n, but slightly slower.\n\n\nSVD\n = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.\n\n\nCG\n = Conjugate-Gradient. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.\n\n\nGMRES\n = GMRES. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is not positive definite.\n\n\nfullSave\n = Makes the algorithm save the output at every \nsaveSteps\n timesteps. By default fullSave is false.\n\n\nsaveSteps\n = If \nfullSave=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\n\n\nFinite Element Poisson Equation Solver\n\n\nsolve(femMesh::FEMmesh,pdeProb::PoissonProblem)\n\n\nTakes in a definition for the heat equation \n-\u0394u = f\n on \nfemMesh\n with functions as defined in \npdeProb\n. If \n\u03c3\n is specified in \npdeProb\n, then this solves the stochastic Poisson equation \n-\u0394u = f + \u03c3dW\n.\n\n\nKeyword Arguments\n\n\n\n\nsolver\n = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation \nAx=b\n. The default is \nLU\n. The choices are:\n\n\nDirect\n = Solves \nAx=b\n using ``\n\n\nCG\n = Conjugate-Gradient. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is positive definite.\n\n\nGMRES\n = GMRES. Best when the space is very large and \nI \u00b1 \u0394tM\u207b\u00b9A\n is not positive definite.\n\n\nsaveSteps\n = If \nfullSave=true\n, then this is the number of steps between the saves.\n\n\nautodiff\n = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.\n\n\nmethod\n = Method the nonlinear solver uses. Defaults to \n:trust_region\n.\n\n\nshow_trace\n = Whether to show the output of the nonlinear solver. Defaults to false.\n\n\niterations\n = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.\n\n\n\n\n#\n\n\nBase.size\n \n \nFunction\n.\n\n\nsize(mesh::FDMMesh)\n\n\nReturns gridSize.\n\n\n#\n\n\nBase.length\n \n \nFunction\n.\n\n\nBase.length(tab::ExplicitRK)\n\n\nDefines the length of a Runge-Kutta method to be the number of stages.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#extra-functions", 
            "text": "#  DifferentialEquations.getNoise     Function .  getNoise(N,node,elem;noiseType=\"White\")  Returns a random vector corresponding to the noise type which was chosen.  #  DifferentialEquations.numparameters     Function .  numparameters(f)  Returns the number of parameters of  f  for the method which has the most parameters.", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#making-build-work", 
            "text": "#  DifferentialEquations.solve     Function .  solve(prob::ODEProblem,\u0394t,T)  Solves the ODE defined by prob with initial \u0394t on the time interval [0,T].  Keyword Arguments   fullSave: Saves the result at every saveSteps steps. Default is false. saveSteps: If fullSave is true, then the output is saved every saveSteps steps.  alg: String which defines the solver algorithm. Defult is \"RK4\". Possibilities are:  \"Euler\" - The canonical forward Euler method.  \"Midpoint\" - The second order midpoint method.  \"RK4\" - The canonical Runge-Kutta Order 4 method.  \"ExplicitRK\" - A general Runge-Kutta solver which takes in a tableau. Can be adaptive.  \"ImplicitEuler\" - A 1st order implicit solver. Unconditionally stable.  \"Trapezoid\" - A second order unconditionally stable implicit solver. Good for highly stiff.  \"Rosenbrock23\" - A fast solver which is good for stiff equations.  tableau - Takes in an object which defines a tableau. Default is Dormand-Prince 4/5.  adaptive - Turns on adaptive timestepping for appropriate methods. Default is false.  tol - The error tolerance of the adaptive method. Default is 1e-4.  \u03b3 - The risk-factor \u03b3 in the q equation for adaptive timestepping. Default is 2.  qmax - Defines the maximum value possible for the adaptive q. Default is 10.   solve(prob::SDEProblem,tspan=[0,1];\u0394t=0)  Solves the SDE as defined by prob with initial \u0394t on the time interval tspan. If not given, tspan defaults to [0,1]. If  Keyword Arguments   fullSave: Saves the result at every saveSteps steps. Default is false. saveSteps: If fullSave is true, then the output is saved every saveSteps steps.  alg: String which defines the solver algorithm. Defult is \"SRI\". Possibilities are:  \"EM\"- The Euler-Maruyama method.  \"RKMil\" - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method.  \"SRA\" - The strong Order 1.5 method for additive SDEs due to Rossler.  \"SRI\" - The strong Order 1.5 method for diagonal/scalar SDEs due to Rossler. Most efficient.   solve(prob::StokesProblem,mesh::FDMMesh)  Solves the given stationary Stokes problem on the given finite difference mesh.  Keyword Arguments   converrors : Whether to calculate all of the errors along the convergence. Default is true.  maxiters : Maximum number of iterations before haulting. Default is 100.  alg : The solver algorithm. Default is \"dgs\". Other option is \"multigrid\".  level : The number of levels in the Multigrid. Default is 2.  smoothSteps : The number of Gauss-Seidel iterations to do at each smoothing step. Default is 10.  coarseSteps : The number of Gauss-Seidel iterations to do at the coarsegrid. Default is 40.  gsiters : The number of Gauss-Seidel iterations to do at each step. Default is 20.   Finite Element Heat Equation Solver  solve(femMesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation  u_t = \u0394u + f  on  femMesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic heat equation  u_t = \u0394u + f + \u03c3dW_t .  Keyword Arguments   alg  = Solution algorithm. Default is Euler. The choices are:  Linear     * Euler (Explicit)     * Implicit Euler (Implicit)     * Crank-Nicholson (Implicit)  Nonlinear     * Euler (Explicit)     * Implicit Euler (Nonlinear Solve)     * Crank-Nicholson (Nonlinear Solve)     * Semi-Implicit Euler (Implicit)     * Semi-Implicit Crank-Nicholson (Implicit)   Explicit algorithms only require solving matrix multiplications  Au . Implicit algorithms require solving the linear equation  Ax=b  where  x  is the unknown. Nonlinear Solve algorithms require solving the nonlinear equation f(x)=0 using methods like Newton's method and is provided by NLSolve.jl. Explicit algorithms have the least stability and should be used either small \u0394t and non-stiff equations. The implicit algorithms have better stability, but for nonlinear equations require costly nonlinear solves in order to be solved exactly. The semi-implicit algorithms discretize with part of the equation implicit and another part explicit in order to allow for the algorithm to not require a nonlinear solve, but at the cost of some stability (though still vastly better at stability than explicit algorithms).   solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:  Direct  = Solves using `` (no factorization). Not recommended.  Cholesky  = Cholsky decomposition. Only stable of  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.     This means that this works best when \u0394t is small. When applicable, this is the fastest.  LU  = LU-Decomposition. A good mix between fast and stable.  QR  = QR-Decomposition. Less numerical roundoff error than  LU , but slightly slower.  SVD  = SVD-Decomposition. By far the slowest, but the most robust to roundoff error.  CG  = Conjugate-Gradient. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.  GMRES  = GMRES. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is not positive definite.  fullSave  = Makes the algorithm save the output at every  saveSteps  timesteps. By default fullSave is false.  saveSteps  = If  fullSave=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.   Finite Element Poisson Equation Solver  solve(femMesh::FEMmesh,pdeProb::PoissonProblem)  Takes in a definition for the heat equation  -\u0394u = f  on  femMesh  with functions as defined in  pdeProb . If  \u03c3  is specified in  pdeProb , then this solves the stochastic Poisson equation  -\u0394u = f + \u03c3dW .  Keyword Arguments   solver  = Linear solver algorithm. This is the algorithm which is chosen for solving the implicit equation  Ax=b . The default is  LU . The choices are:  Direct  = Solves  Ax=b  using ``  CG  = Conjugate-Gradient. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is positive definite.  GMRES  = GMRES. Best when the space is very large and  I \u00b1 \u0394tM\u207b\u00b9A  is not positive definite.  saveSteps  = If  fullSave=true , then this is the number of steps between the saves.  autodiff  = Whether or not autodifferentiation (as provided by AutoDiff.jl) is used for the nonlinear solving. By default autodiff is false.  method  = Method the nonlinear solver uses. Defaults to  :trust_region .  show_trace  = Whether to show the output of the nonlinear solver. Defaults to false.  iterations  = Maximum numer of iterations in the nonlinear solver. Defaults to 1000.   #  Base.size     Function .  size(mesh::FDMMesh)  Returns gridSize.  #  Base.length     Function .  Base.length(tab::ExplicitRK)  Defines the length of a Runge-Kutta method to be the number of stages.  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation", 
            "title": "Making Build Work"
        }, 
        {
            "location": "/internals/solverHelpers/", 
            "text": "Solver Helpers\n\n\nThis package includes the documentation for the helper functions for the various solvers.\n\n\n\n\nODE\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nBase.length(tab::ExplicitRK)\n\n\nDefines the length of a Runge-Kutta method to be the number of stages.\n\n\n\n\nStationary Stokes\n\n\n#\n\n\nDifferentialEquations.GS\u03b4q!\n \n \nFunction\n.\n\n\nGS\u03b4q!(\u03b4q,rp,\u0394xs)\n\n\nPerforms a Gauss-Seidel iteration for \u03b4q.\n\n\n#\n\n\nDifferentialEquations.GSu!\n \n \nFunction\n.\n\n\nGSu!(u,f\u2081,\u0394xs,p,ugD,grids,ux,uy)\n\n\nPerforms a Gauss-Seidel iteration on u.\n\n\n#\n\n\nDifferentialEquations.calc_rp!\n \n \nFunction\n.\n\n\ncalc_rp!(rp,u,v,\u0394xs,g,px,py)\n\n\nCalculates the rp from the u and v's.\n\n\n#\n\n\nDifferentialEquations.update_p!\n \n \nFunction\n.\n\n\nupdate_p!(p,\u03b4q,\u0394xs)\n\n\nUpdates p given \u03b4q\n\n\n#\n\n\nDifferentialEquations.update_v!\n \n \nFunction\n.\n\n\nupdate_v!(v,\u03b4q,\u0394xs)\n\n\nUpdates v given \u03b4q\n\n\n#\n\n\nDifferentialEquations.uzawa_p!\n \n \nFunction\n.\n\n\nuzawa_p!(p,u,v,\u0394xs,g,px,py)\n\n\nSolves for p from u and v using an Uzawa update.\n\n\n#\n\n\nDifferentialEquations.stokes_restriction\n \n \nFunction\n.\n\n\nstokes_restriction(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)\n\n\nRestricts the Stokes problem to the coarsegrid.\n\n\n#\n\n\nDifferentialEquations.stokes_prolongation\n \n \nFunction\n.\n\n\nstokes_prolongation(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)\n\n\nProlongates the Stokes problem to the fine grid\n\n\n#\n\n\nDifferentialEquations.update_u!\n \n \nFunction\n.\n\n\nupdate_u!(u,\u03b4q,\u0394xs)\n\n\nUpdates u given \u03b4q\n\n\n#\n\n\nDifferentialEquations.GSv!\n \n \nFunction\n.\n\n\nGSv!(v,f\u2082,\u0394xs,p,vgD,grids,vx,vy)\n\n\nPerforms a Gauss-Seidel iteration on v.", 
            "title": "Solver Helpers"
        }, 
        {
            "location": "/internals/solverHelpers/#solver-helpers", 
            "text": "This package includes the documentation for the helper functions for the various solvers.", 
            "title": "Solver Helpers"
        }, 
        {
            "location": "/internals/solverHelpers/#ode", 
            "text": "#  Base.length     Method .  Base.length(tab::ExplicitRK)  Defines the length of a Runge-Kutta method to be the number of stages.", 
            "title": "ODE"
        }, 
        {
            "location": "/internals/solverHelpers/#stationary-stokes", 
            "text": "#  DifferentialEquations.GS\u03b4q!     Function .  GS\u03b4q!(\u03b4q,rp,\u0394xs)  Performs a Gauss-Seidel iteration for \u03b4q.  #  DifferentialEquations.GSu!     Function .  GSu!(u,f\u2081,\u0394xs,p,ugD,grids,ux,uy)  Performs a Gauss-Seidel iteration on u.  #  DifferentialEquations.calc_rp!     Function .  calc_rp!(rp,u,v,\u0394xs,g,px,py)  Calculates the rp from the u and v's.  #  DifferentialEquations.update_p!     Function .  update_p!(p,\u03b4q,\u0394xs)  Updates p given \u03b4q  #  DifferentialEquations.update_v!     Function .  update_v!(v,\u03b4q,\u0394xs)  Updates v given \u03b4q  #  DifferentialEquations.uzawa_p!     Function .  uzawa_p!(p,u,v,\u0394xs,g,px,py)  Solves for p from u and v using an Uzawa update.  #  DifferentialEquations.stokes_restriction     Function .  stokes_restriction(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)  Restricts the Stokes problem to the coarsegrid.  #  DifferentialEquations.stokes_prolongation     Function .  stokes_prolongation(u,v,p,\u0394xs,grids,mins,maxs,ugD,vgD)  Prolongates the Stokes problem to the fine grid  #  DifferentialEquations.update_u!     Function .  update_u!(u,\u03b4q,\u0394xs)  Updates u given \u03b4q  #  DifferentialEquations.GSv!     Function .  GSv!(v,f\u2082,\u0394xs,p,vgD,grids,vx,vy)  Performs a Gauss-Seidel iteration on v.", 
            "title": "Stationary Stokes"
        }
    ]
}