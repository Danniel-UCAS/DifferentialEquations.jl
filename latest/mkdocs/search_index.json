{
    "docs": [
        {
            "location": "/", 
            "text": "DifferentialEquations.jl Documentation\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see \nODE.jl\n\n\nThis package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.\n\n\nIf at any time you run into documentation that is incomplete/confusing, please contact me via the Gitter channel and I will clear it up!\n\n\n\n\nUsing the Package\n\n\nTo install the package, use the following command inside the Julia REPL:\n\n\nPkg.clone(\nhttps://github.com/ChrisRackauckas/DifferentialEquations.jl\n)\n\n\n\n\nTo load the package, use the command\n\n\nusing DifferentialEquations\n\n\n\n\nTo understand the package in more detail, check out the following tutorials. Example codes for the latest features can be found in \ntest/\n. Note that for many of the examples in the test folder, you may wish to run them at lower \u0394x or \u0394t. These values were taken to be large in order make unit tests run faster! Due to the fast development speed of the package, it is recommended you checkout the main branch:\n\n\nPkg.checkout(\nDifferentialEquations\n)\n\n\n\n\nThis will keep your local repository up to date with the latest changes.\n\n\n\n\nTutorials\n\n\nThe following tutorials will introduce you to the functionality of DifferentialEquations.jl\n\n\n\n\nPoisson Equation Finite Element Method Example\n\n\nHeat Equation Finite Element Method Example\n\n\nStochastic Finite Element Examples\n\n\nFinite Element Stochastic Poisson Equation\n\n\nFinite Element Stochastic Heat Equation\n\n\n\n\n\n\n\n\n\n\nManual\n\n\n\n\nOverview of DifferentialEquations.jl Usage\n\n\nCommon Terms\n\n\nDefining a Problem\n\n\nPoisson Equation Problem\n\n\nHeat Equation Problem\n\n\nExample Problems\n\n\nRelated Functions\n\n\n\n\n\n\nMesh Generation\n\n\nMesh Specification\n\n\nMesh Type\n\n\nMesh Generation Functions\n\n\n\n\n\n\nInformation on Solvers\n\n\nFinite Element Method Solvers\n\n\n\n\n\n\nThe Solution Type\n\n\nRelated Functions\n\n\n\n\n\n\nPlot Functions\n\n\nRelated Functions\n\n\n\n\n\n\nConvergence Simulations\n\n\nThe ConvergenceSimulation Type\n\n\nRelated Functions\n\n\nPlot Functions\n\n\n\n\n\n\n\n\n\n\nInternal Documentation\n\n\n\n\nInternal Finite Element Tools\n\n\nGeneral\n\n\nMesh Tools\n\n\nSolver Tools\n\n\nError Tools\n\n\n\n\n\n\nExtra Functions\n\n\n\n\n\n\nIndex\n\n\n\n\nDifferentialEquations.CG2\n\n\nDifferentialEquations.checkIfLoaded\n\n\nDifferentialEquations.modulechildren\n\n\nDifferentialEquations.quadfbasis2\n\n\nDifferentialEquations\n\n\nDifferentialEquations.CFL\u03bc\n\n\nDifferentialEquations.CFL\u03bd\n\n\nDifferentialEquations.accumarray\n\n\nDifferentialEquations.assemblematrix\n\n\nDifferentialEquations.getH1error\n\n\nDifferentialEquations.getL2error\n\n\nDifferentialEquations.gradbasis\n\n\nDifferentialEquations.gradu\n\n\nDifferentialEquations.meshgrid\n\n\nDifferentialEquations.quadfbasis\n\n\nDifferentialEquations.quadpts\n\n\nBase.length\n\n\nDifferentialEquations.ConvergenceSimulation\n\n\nDifferentialEquations.conv_ests\n\n\nDifferentialEquations.convplot_full\u0394t\n\n\nDifferentialEquations.convplot_full\u0394x\n\n\nDifferentialEquations.convplot_h1vs\u0394t\n\n\nDifferentialEquations.convplot_h1vs\u0394x\n\n\nDifferentialEquations.convplot_l2vs\u0394t\n\n\nDifferentialEquations.convplot_l2vs\u0394x\n\n\nDifferentialEquations.convplot_maxvs\u0394t\n\n\nDifferentialEquations.convplot_maxvs\u0394x\n\n\nDifferentialEquations.convplot_node2vs\u0394t\n\n\nDifferentialEquations.convplot_node2vs\u0394x\n\n\nDifferentialEquations.FEMmesh\n\n\nDifferentialEquations.SimpleMesh\n\n\nDifferentialEquations.fem_squaremesh\n\n\nDifferentialEquations.findboundary\n\n\nDifferentialEquations.notime_squaremesh\n\n\nDifferentialEquations.parabolic_squaremesh\n\n\nDifferentialEquations.setboundary\n\n\nDifferentialEquations.convplot\n\n\nDifferentialEquations.showmesh\n\n\nDifferentialEquations.solplot\n\n\nDifferentialEquations.solplot_animation\n\n\nDifferentialEquations.solplot_appx\n\n\nDifferentialEquations.solplot_appxvstrue\n\n\nDifferentialEquations.HeatProblem\n\n\nDifferentialEquations.PdeProblem\n\n\nDifferentialEquations.PoissonProblem\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n\n\nDifferentialEquations.heatProblemExample_diffuse\n\n\nDifferentialEquations.heatProblemExample_moving\n\n\nDifferentialEquations.heatProblemExample_pure\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n\n\nDifferentialEquations.poissonProblemExample_wave\n\n\nDifferentialEquations.FEMSolution\n\n\nDifferentialEquations.PdeSolution\n\n\nDifferentialEquations.appxTrue!\n\n\nDifferentialEquations.fem_solveheat\n\n\nDifferentialEquations.fem_solvepoisson", 
            "title": "Introduction"
        }, 
        {
            "location": "/#differentialequationsjl-documentation", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see  ODE.jl  This package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.  If at any time you run into documentation that is incomplete/confusing, please contact me via the Gitter channel and I will clear it up!", 
            "title": "DifferentialEquations.jl Documentation"
        }, 
        {
            "location": "/#using-the-package", 
            "text": "To install the package, use the following command inside the Julia REPL:  Pkg.clone( https://github.com/ChrisRackauckas/DifferentialEquations.jl )  To load the package, use the command  using DifferentialEquations  To understand the package in more detail, check out the following tutorials. Example codes for the latest features can be found in  test/ . Note that for many of the examples in the test folder, you may wish to run them at lower \u0394x or \u0394t. These values were taken to be large in order make unit tests run faster! Due to the fast development speed of the package, it is recommended you checkout the main branch:  Pkg.checkout( DifferentialEquations )  This will keep your local repository up to date with the latest changes.", 
            "title": "Using the Package"
        }, 
        {
            "location": "/#tutorials", 
            "text": "The following tutorials will introduce you to the functionality of DifferentialEquations.jl   Poisson Equation Finite Element Method Example  Heat Equation Finite Element Method Example  Stochastic Finite Element Examples  Finite Element Stochastic Poisson Equation  Finite Element Stochastic Heat Equation", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#manual", 
            "text": "Overview of DifferentialEquations.jl Usage  Common Terms  Defining a Problem  Poisson Equation Problem  Heat Equation Problem  Example Problems  Related Functions    Mesh Generation  Mesh Specification  Mesh Type  Mesh Generation Functions    Information on Solvers  Finite Element Method Solvers    The Solution Type  Related Functions    Plot Functions  Related Functions    Convergence Simulations  The ConvergenceSimulation Type  Related Functions  Plot Functions", 
            "title": "Manual"
        }, 
        {
            "location": "/#internal-documentation", 
            "text": "Internal Finite Element Tools  General  Mesh Tools  Solver Tools  Error Tools    Extra Functions", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/#index", 
            "text": "DifferentialEquations.CG2  DifferentialEquations.checkIfLoaded  DifferentialEquations.modulechildren  DifferentialEquations.quadfbasis2  DifferentialEquations  DifferentialEquations.CFL\u03bc  DifferentialEquations.CFL\u03bd  DifferentialEquations.accumarray  DifferentialEquations.assemblematrix  DifferentialEquations.getH1error  DifferentialEquations.getL2error  DifferentialEquations.gradbasis  DifferentialEquations.gradu  DifferentialEquations.meshgrid  DifferentialEquations.quadfbasis  DifferentialEquations.quadpts  Base.length  DifferentialEquations.ConvergenceSimulation  DifferentialEquations.conv_ests  DifferentialEquations.convplot_full\u0394t  DifferentialEquations.convplot_full\u0394x  DifferentialEquations.convplot_h1vs\u0394t  DifferentialEquations.convplot_h1vs\u0394x  DifferentialEquations.convplot_l2vs\u0394t  DifferentialEquations.convplot_l2vs\u0394x  DifferentialEquations.convplot_maxvs\u0394t  DifferentialEquations.convplot_maxvs\u0394x  DifferentialEquations.convplot_node2vs\u0394t  DifferentialEquations.convplot_node2vs\u0394x  DifferentialEquations.FEMmesh  DifferentialEquations.SimpleMesh  DifferentialEquations.fem_squaremesh  DifferentialEquations.findboundary  DifferentialEquations.notime_squaremesh  DifferentialEquations.parabolic_squaremesh  DifferentialEquations.setboundary  DifferentialEquations.convplot  DifferentialEquations.showmesh  DifferentialEquations.solplot  DifferentialEquations.solplot_animation  DifferentialEquations.solplot_appx  DifferentialEquations.solplot_appxvstrue  DifferentialEquations.HeatProblem  DifferentialEquations.PdeProblem  DifferentialEquations.PoissonProblem  DifferentialEquations.heatProblemExample_birthdeath  DifferentialEquations.heatProblemExample_diffuse  DifferentialEquations.heatProblemExample_moving  DifferentialEquations.heatProblemExample_pure  DifferentialEquations.heatProblemExample_stochasticbirthdeath  DifferentialEquations.poissonProblemExample_birthdeath  DifferentialEquations.poissonProblemExample_noisyWave  DifferentialEquations.poissonProblemExample_wave  DifferentialEquations.FEMSolution  DifferentialEquations.PdeSolution  DifferentialEquations.appxTrue!  DifferentialEquations.fem_solveheat  DifferentialEquations.fem_solvepoisson", 
            "title": "Index"
        }, 
        {
            "location": "/tutorials/femPoisson/", 
            "text": "Poisson Equation Finite Element Method Example\n\n\nIn this example we will solve the Poisson Equation \n$\u0394u=f$\n. The code for this example can be found in \ntests/introductionExample.jl\n. For our example, we will take the linear equation where \nf(x,y) = sin(2\u03c0.*x).*cos(2\u03c0.*y)\n. For this equation we know that solution is \nu(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n with gradient \nDu(x,y) = [cos(2*pi.*x).*cos(2*pi.*y)./(4*pi) -sin(2\u03c0.*x).*sin(2\u03c0.*y)./(4\u03c0)]\n. Thus, we define a PoissonProblem as follows:\n\n\nExample problem with solution: u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\nfunction poissonProblemExample_wave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  return(PoissonProblem(f,sol,Du,gN,isLinear))\nend\npdeProb = poissonProblemExample_wave()\n\n\n\n\nNote that in this case since the solution is known, the Dirichlet boundary condition \ngD\n is automatically set to match the true solution. The code for other example problems can be found in \nsrc/examples/exampleProblems.jl\n. To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:\n\n\n\u0394x = 1//2^(5)\nfemMesh = notime_squaremesh([0 1 0 1],\u0394x,\nDirichlet\n)\n\n\n\n\nNote that by specifying \"Dirichlet\" our boundary conditions is set on all boundaries to Dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as \niFEM\n. Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use\n\n\nres = fem_solvepoisson(femMesh::FEMmesh,pdeProb::PoissonProblem,solver=\nGMRES\n)\n\n\n\n\nfem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This reurns a FEMSolution object which holds data about the solution, such as the solution values (u), the true solution (uTrue), error estimates, etc. To plot the solution, we use the command\n\n\nsolplot(res,savefile=\nintroductionExample.png\n)\n\n\n\n\nThis gives us the following plot:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femPoisson/#poisson-equation-finite-element-method-example", 
            "text": "In this example we will solve the Poisson Equation  $\u0394u=f$ . The code for this example can be found in  tests/introductionExample.jl . For our example, we will take the linear equation where  f(x,y) = sin(2\u03c0.*x).*cos(2\u03c0.*y) . For this equation we know that solution is  u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)  with gradient  Du(x,y) = [cos(2*pi.*x).*cos(2*pi.*y)./(4*pi) -sin(2\u03c0.*x).*sin(2\u03c0.*y)./(4\u03c0)] . Thus, we define a PoissonProblem as follows:  Example problem with solution: u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0) \nfunction poissonProblemExample_wave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  return(PoissonProblem(f,sol,Du,gN,isLinear))\nend\npdeProb = poissonProblemExample_wave()  Note that in this case since the solution is known, the Dirichlet boundary condition  gD  is automatically set to match the true solution. The code for other example problems can be found in  src/examples/exampleProblems.jl . To solve this problem, we first have to generate a mesh. Here we will simply generate a mesh of triangles on the square [0,1]x[0,1] with \u0394x=2^(-5). To do so, we use the code:  \u0394x = 1//2^(5)\nfemMesh = notime_squaremesh([0 1 0 1],\u0394x, Dirichlet )  Note that by specifying \"Dirichlet\" our boundary conditions is set on all boundaries to Dirichlet. This gives an FEMmesh object which stores a finite element mesh in the same layout as  iFEM . Notice this code shows that the package supports the use of rationals in meshes. Other numbers such as floating point and integers can be used as well. Finally, to solve the equation we use  res = fem_solvepoisson(femMesh::FEMmesh,pdeProb::PoissonProblem,solver= GMRES )  fem_solvepoisson takes in a mesh and a PoissonProblem and uses the solver to compute the solution. Here the solver was chosen to be GMRES. Other solvers can be found in the documentation. This reurns a FEMSolution object which holds data about the solution, such as the solution values (u), the true solution (uTrue), error estimates, etc. To plot the solution, we use the command  solplot(res,savefile= introductionExample.png )  This gives us the following plot:", 
            "title": "Poisson Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femHeat/", 
            "text": "Heat Equation Finite Element Method Example\n\n\nIn this example we will solve the heat equation \nu_t=\u0394u+f\n. To do this, we define a HeatProblem which contains the function \nf\n and the boundary conditions. We specify one as follows:\n\n\nExample problem which starts with 0 and solves with f(u)=1-.1u\n\nfunction heatProblemExample_birthdeath()\n  gD(x,t) = zeros(size(x,1))\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  gN(x,t) = 0\n  isLinear = false\n  return(HeatProblem(u0,f,gD,gN,isLinear))\nend\npdeProb = heatProblemExample_birthdeath()\n\n\n\n\nHere the equation we chose was nonlinear since \nf\n depends on the variable \nu\n. Thus we specify f=f(u,x,t) and set isLinear = false. If \nf\n did not depend on u, then we would specify f=f(x,t) and \nisLinear = true\n. \ngD\n specifies the condition on the Dirichlet part of the boundary and \ngN\n specifies the condition on the Neumann part of the boundary. \nu0\n specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.\n\n\nWe then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command\n\n\nT = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,\nDirichlet\n)\n\n\n\n\nWe then call the appropriate solver\n\n\nres = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg=\nEuler\n)\n\n\n\n\nHere we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femHeat/#heat-equation-finite-element-method-example", 
            "text": "In this example we will solve the heat equation  u_t=\u0394u+f . To do this, we define a HeatProblem which contains the function  f  and the boundary conditions. We specify one as follows:  Example problem which starts with 0 and solves with f(u)=1-.1u \nfunction heatProblemExample_birthdeath()\n  gD(x,t) = zeros(size(x,1))\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  gN(x,t) = 0\n  isLinear = false\n  return(HeatProblem(u0,f,gD,gN,isLinear))\nend\npdeProb = heatProblemExample_birthdeath()  Here the equation we chose was nonlinear since  f  depends on the variable  u . Thus we specify f=f(u,x,t) and set isLinear = false. If  f  did not depend on u, then we would specify f=f(x,t) and  isLinear = true .  gD  specifies the condition on the Dirichlet part of the boundary and  gN  specifies the condition on the Neumann part of the boundary.  u0  specifies the initial condition. These together give a HeatProblem object which holds everything which specifies a Heat Equation Problem.  We then generate a mesh. We will solve the equation on the parabolic cylinder [0,1]^2 x [0,1]. You can think of this as the cube, or at every time point from 0 to 1, the domain is the unit square. To generate this mesh, we use the command  T = 1\n\u0394x = 1//2^(3)\n\u0394t = 1//2^(7)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T, Dirichlet )  We then call the appropriate solver  res = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg= Euler )  Here we have chosen to use the Euler algorithm to solve the equation. Other algorithms and their descriptions can be found in the solvers part of the documentation.", 
            "title": "Heat Equation Finite Element Method Example"
        }, 
        {
            "location": "/tutorials/femStochastic/", 
            "text": "Stochastic Finite Element Examples\n\n\nFor most problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments \ndW\n, and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noiseType which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.\n\n\nThe following examples show how to change the tutorial problems into stochastic problems.\n\n\n\n\nFinite Element Stochastic Poisson Equation\n\n\nWe can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,  \n-\u0394u=f+gdW\n, with additive space-time white noise by specifying the problem as:\n\n\nExample problem with deterministic solution: u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0)\n\nfunction poissonProblemExample_noisyWave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  stochastic = true\n  \u03c3(x) = 5 #Additive noise, a big amount!\n  return(PoissonProblem(f,sol,Du,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend\n\n\n\n\nusing the same solving commands as shown in \nfemStochasticPoissonSolo.jl\n. This gives the following plot:\n\n\n\n\n\n\nFinite Element Stochastic Heat Equation\n\n\nThis will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function \nf(u)=.5-u\n, noise function \ng(u)=100u^2\n and initial condition \nu0=0\n. We would expect this system to rise towards the deterministic steady state \nu=2\n (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:\n\n\nExample problem which starts with 0 and solves with f(u)=1-.1u\n\nfunction heatProblemExample_stochasticbirthdeath()\n  gD(x,t) = zeros(size(x,1))\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  gN(x,t) = 0\n  isLinear = false\n  stochastic = true\n  \u03c3(u,x,t) = 100u.^2\n  return(HeatProblem(u0,f,gD,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend\n\n\n\n\nAs shown in \nfemStochasticHeatAnimationTest.jl\n, we use the following code create an animation of the solution:\n\n\nT = 5\n\u0394x = 1//2^(4)\n\u0394t = 1//2^(12)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T,\nNeumann\n)\npdeProb = heatProblemExample_stochasticbirthdeath()\n\nres = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg=\nEuler\n,fullSave=true)\nsolplot_animation(res::FEMSolution;zlim=(0,2),vmax=.1,cbar=false)", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femStochastic/#stochastic-finite-element-examples", 
            "text": "For most problem types, we can additionally specify them as a stochastic problem by giving the appropriate optional arguments to the constructor. These arguments are a function \u03c3 which is the function multiplied to the Brownian increments  dW , and stochastic, a boolean which we put as true for when the equation is stochastic. Another keyword that is optional is noiseType which specifies the type of noise (the \"color\" of the noise). By default this is Gaussian (Space-time) White Noise.  The following examples show how to change the tutorial problems into stochastic problems.", 
            "title": "Stochastic Finite Element Examples"
        }, 
        {
            "location": "/tutorials/femStochastic/#finite-element-stochastic-poisson-equation", 
            "text": "We can solve the same PDE as in the Poisson Tutorial except as the stochastic PDE,   -\u0394u=f+gdW , with additive space-time white noise by specifying the problem as:  Example problem with deterministic solution: u(x,y,t)= sin(2\u03c0.*x).*cos(2\u03c0.*y)/(8\u03c0*\u03c0) \nfunction poissonProblemExample_noisyWave()\n  f(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])\n  sol(x) = sin(2\u03c0.*x[:,1]).*cos(2\u03c0.*x[:,2])/(8\u03c0*\u03c0)\n  Du(x) = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2\u03c0.*x[:,1]).*sin(2\u03c0.*x[:,2])./(4\u03c0)]\n  gN(x) = 0\n  isLinear = true\n  stochastic = true\n  \u03c3(x) = 5 #Additive noise, a big amount!\n  return(PoissonProblem(f,sol,Du,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend  using the same solving commands as shown in  femStochasticPoissonSolo.jl . This gives the following plot:", 
            "title": "Finite Element Stochastic Poisson Equation"
        }, 
        {
            "location": "/tutorials/femStochastic/#finite-element-stochastic-heat-equation", 
            "text": "This will solve a nonlinear stochastic heat equation u_t=\u0394u+f+gdW with forcing function  f(u)=.5-u , noise function  g(u)=100u^2  and initial condition  u0=0 . We would expect this system to rise towards the deterministic steady state  u=2  (but stay in mean a bit below it due to 1st order \"Milstein\" effects), gaining more noise as it increases. This is specified as follows:  Example problem which starts with 0 and solves with f(u)=1-.1u \nfunction heatProblemExample_stochasticbirthdeath()\n  gD(x,t) = zeros(size(x,1))\n  f(u,x,t)  = ones(size(x,1)) - .5u\n  u0(x) = zeros(size(x,1))\n  gN(x,t) = 0\n  isLinear = false\n  stochastic = true\n  \u03c3(u,x,t) = 100u.^2\n  return(HeatProblem(u0,f,gD,gN,isLinear,\u03c3=\u03c3,stochastic=stochastic))\nend  As shown in  femStochasticHeatAnimationTest.jl , we use the following code create an animation of the solution:  T = 5\n\u0394x = 1//2^(4)\n\u0394t = 1//2^(12)\nfemMesh = parabolic_squaremesh([0 1 0 1],\u0394x,\u0394t,T, Neumann )\npdeProb = heatProblemExample_stochasticbirthdeath()\n\nres = fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem,alg= Euler ,fullSave=true)\nsolplot_animation(res::FEMSolution;zlim=(0,2),vmax=.1,cbar=false)", 
            "title": "Finite Element Stochastic Heat Equation"
        }, 
        {
            "location": "/man/overview/", 
            "text": "Overview of DifferentialEquations.jl Usage\n\n\nThe general workflow for using the package is as follows:\n\n\n\n\nDefine a problem\n\n\nGenerate a mesh\n\n\nUse a solver on the problem and mesh\n\n\nAnalyze the output\n\n\n\n\nProblems are specified via a type interface. For example, for the Poisson equation \n\u0394u = f\n, one defines a type which holds \nf\n and the boundary condition functions.\n\n\nNext, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. [0,1]^2 x [0,T], then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.\n\n\nOne then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.\n\n\nWith the solution object, you do the analysis as you please! For some result \nres\n, the field \nres.u\n returns the final solution, and if you give a true solution, \nres.uTrue\n is the true solution at the final time. If you specified to the solver \nfullSave=true\n, then \nres.uFull\n and \nres.tFull\n will be outputted which hold the solution/time at every \nsaveSteps\n (default set to 100, meaning it saves an output every 100 steps).\n\n\nHowever, DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. Various plotter functions take in result types and use these to make standard plots. If \nfullSave\n was used, the plotters can generate animations of the solutions to evolution equations.  An array of solutions can be made into a \nConvergenceSimulation\n which then generates all of the convergence test results and allows for plotting (great for developing new methods!).", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/overview/#overview-of-differentialequationsjl-usage", 
            "text": "The general workflow for using the package is as follows:   Define a problem  Generate a mesh  Use a solver on the problem and mesh  Analyze the output   Problems are specified via a type interface. For example, for the Poisson equation  \u0394u = f , one defines a type which holds  f  and the boundary condition functions.  Next, one generates a mesh. For example, if one wants to solve the Heat equation in the parabolic cylinder of the unit square, i.e. [0,1]^2 x [0,T], then one has to discretize this. Tools within the package will generate meshes from general characteristics. For example, most tools require only specifying the general shape, \u0394x, \u0394t, and T and will generate the mesh.  One then passes the mesh and the problem to the solver interface. The solver then solves the differential equation using the some numerical methods (which can be specified via keyword arguments). The solver returns a solution object which hold all of the details for the solution.  With the solution object, you do the analysis as you please! For some result  res , the field  res.u  returns the final solution, and if you give a true solution,  res.uTrue  is the true solution at the final time. If you specified to the solver  fullSave=true , then  res.uFull  and  res.tFull  will be outputted which hold the solution/time at every  saveSteps  (default set to 100, meaning it saves an output every 100 steps).  However, DifferentialEquations.jl also provides some helper functionality to assist with general forms of analysis. Various plotter functions take in result types and use these to make standard plots. If  fullSave  was used, the plotters can generate animations of the solutions to evolution equations.  An array of solutions can be made into a  ConvergenceSimulation  which then generates all of the convergence test results and allows for plotting (great for developing new methods!).", 
            "title": "Overview of DifferentialEquations.jl Usage"
        }, 
        {
            "location": "/man/commonTerms/", 
            "text": "Common Terms", 
            "title": "Common Terms"
        }, 
        {
            "location": "/man/commonTerms/#common-terms", 
            "text": "", 
            "title": "Common Terms"
        }, 
        {
            "location": "/man/problem/", 
            "text": "Defining a Problem\n\n\n(x,t) vs (x,y,t) isLinear stochastic\n\n\n\n\nPoisson Equation Problem\n\n\n#\n\n\nDifferentialEquations.PoissonProblem\n \n \nType\n.\n\n\nPoissonProblem\n\n\nWraps the data that define a 2D linear Poisson equation problem:\n\n\n$ (generic function with 34 methods) \u0394u = f(x,t) $ (generic function with 34 methods)\n\n\nConstructors\n\n\nPoissonProblem(f,sol,Du,gN,isLinear): Defines the Dirichlet problem with solution sol, solution gradient Du = [u_x,u_y], f, and Neumann boundary data gN,\n\n\nPoissonProblem(u0,f,gD,gN,isLinear): Defines the problem with initial value u0 (as a function or vector), f, Dirichlet boundary function gD, and Neumann boundary function gN.\n\n\nNote: If isLinear is true, then all functions must only be functions of (x). If isLinear is false, then f=f(u,x) and \u03c3=\u03c3(u,x) (if specified), while the other functions are only functions of (x).\n\n\nKeyword Arguments\n\n\n\u03c3\n = The function which multiplies the noise \ndW\n. By default \n\u03c3\n is 0.\n\n\nnoiseType = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.\n\n\n\n\nHeat Equation Problem\n\n\n#\n\n\nDifferentialEquations.HeatProblem\n \n \nType\n.\n\n\nHeatProblem\n\n\nWraps the data that define a 2D linear heat equation problem:\n\n\n$ (generic function with 34 methods) u_t = \u0394u + f(x,t) $ (generic function with 34 methods)\n\n\nConstructors\n\n\nHeatProblem(sol,Du,f,isLinear): Defines the Dirichlet problem with solution sol, solution gradient Du = [u_x,u_y], f, and a boolean which states whether the problem is linear (i.e. linear if f does not depend on u).\n\n\nHeatProblem(u0,f,gD,gN,isLinear): Defines the problem with initial value u0 (as a function or vector), f, Dirichlet boundary function gD,  Neumann boundary function gN, and a boolean which states whether the problem is linear (i.e. linear if f does not depend on u).\n\n\nNote: If isLinear is true, then all functions must only be functions of (x,t). If isLinear is false, then f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified), while the other functions are only functions of (x,t).\n\n\nKeyword Arguments\n\n\nThe constructors take the following keyword arguments:\n\n\n\u03c3 = The function which multiplies the noise dW. By default \u03c3 is 0.\n\n\nstochastic = A boolean which specifies if the problem is stochastic. By default stochastic is false.\n\n\nnoiseType = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.\n\n\n\n\nExample Problems\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_wave\n \n \nFunction\n.\n\n\nExample problem with solution: u(x,y,t)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_noisyWave\n \n \nFunction\n.\n\n\nExample problem with deterministic solution: u(x,y,t)= sin(2\u03c0.\nx).\ncos(2\u03c0.\ny)/(8\u03c0\n\u03c0)\n\n\n#\n\n\nDifferentialEquations.poissonProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem for nonlinear Poisson equation\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_diffuse\n \n \nFunction\n.\n\n\nExample problem with solution: u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_pure\n \n \nFunction\n.\n\n\nExample problem which starts with 1 at (0.5,0.5) and solves with f=gD=0\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_moving\n \n \nFunction\n.\n\n\nExample problem with solution: u(x,y,t)=0.1\n(1-exp(-100\n(t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_birthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with f(u)=1-.1u\n\n\n#\n\n\nDifferentialEquations.heatProblemExample_stochasticbirthdeath\n \n \nFunction\n.\n\n\nExample problem which starts with 0 and solves with f(u)=1-.1u\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.PdeProblem\n \n \nType\n.\n\n\nPdeProblem: Defines PDE problems via its internal functions", 
            "title": "Defining a Problem"
        }, 
        {
            "location": "/man/problem/#defining-a-problem", 
            "text": "(x,t) vs (x,y,t) isLinear stochastic", 
            "title": "Defining a Problem"
        }, 
        {
            "location": "/man/problem/#poisson-equation-problem", 
            "text": "#  DifferentialEquations.PoissonProblem     Type .  PoissonProblem  Wraps the data that define a 2D linear Poisson equation problem:  $ (generic function with 34 methods) \u0394u = f(x,t) $ (generic function with 34 methods)", 
            "title": "Poisson Equation Problem"
        }, 
        {
            "location": "/man/problem/#constructors", 
            "text": "PoissonProblem(f,sol,Du,gN,isLinear): Defines the Dirichlet problem with solution sol, solution gradient Du = [u_x,u_y], f, and Neumann boundary data gN,  PoissonProblem(u0,f,gD,gN,isLinear): Defines the problem with initial value u0 (as a function or vector), f, Dirichlet boundary function gD, and Neumann boundary function gN.  Note: If isLinear is true, then all functions must only be functions of (x). If isLinear is false, then f=f(u,x) and \u03c3=\u03c3(u,x) (if specified), while the other functions are only functions of (x).", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/problem/#keyword-arguments", 
            "text": "\u03c3  = The function which multiplies the noise  dW . By default  \u03c3  is 0.  noiseType = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/problem/#heat-equation-problem", 
            "text": "#  DifferentialEquations.HeatProblem     Type .  HeatProblem  Wraps the data that define a 2D linear heat equation problem:  $ (generic function with 34 methods) u_t = \u0394u + f(x,t) $ (generic function with 34 methods)", 
            "title": "Heat Equation Problem"
        }, 
        {
            "location": "/man/problem/#constructors_1", 
            "text": "HeatProblem(sol,Du,f,isLinear): Defines the Dirichlet problem with solution sol, solution gradient Du = [u_x,u_y], f, and a boolean which states whether the problem is linear (i.e. linear if f does not depend on u).  HeatProblem(u0,f,gD,gN,isLinear): Defines the problem with initial value u0 (as a function or vector), f, Dirichlet boundary function gD,  Neumann boundary function gN, and a boolean which states whether the problem is linear (i.e. linear if f does not depend on u).  Note: If isLinear is true, then all functions must only be functions of (x,t). If isLinear is false, then f=f(u,x,t) and \u03c3=\u03c3(u,x,t) (if specified), while the other functions are only functions of (x,t).", 
            "title": "Constructors"
        }, 
        {
            "location": "/man/problem/#keyword-arguments_1", 
            "text": "The constructors take the following keyword arguments:  \u03c3 = The function which multiplies the noise dW. By default \u03c3 is 0.  stochastic = A boolean which specifies if the problem is stochastic. By default stochastic is false.  noiseType = A string which specifies the type of noise to be generated. By default noiseType is \"White\" for Gaussian Spacetime White Noise.", 
            "title": "Keyword Arguments"
        }, 
        {
            "location": "/man/problem/#example-problems", 
            "text": "#  DifferentialEquations.poissonProblemExample_wave     Function .  Example problem with solution: u(x,y,t)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)  #  DifferentialEquations.poissonProblemExample_noisyWave     Function .  Example problem with deterministic solution: u(x,y,t)= sin(2\u03c0. x). cos(2\u03c0. y)/(8\u03c0 \u03c0)  #  DifferentialEquations.poissonProblemExample_birthdeath     Function .  Example problem for nonlinear Poisson equation  #  DifferentialEquations.heatProblemExample_diffuse     Function .  Example problem with solution: u(x,y,t)=exp(-10((x-.5).^2 + (y-.5).^2 )-t)  #  DifferentialEquations.heatProblemExample_pure     Function .  Example problem which starts with 1 at (0.5,0.5) and solves with f=gD=0  #  DifferentialEquations.heatProblemExample_moving     Function .  Example problem with solution: u(x,y,t)=0.1 (1-exp(-100 (t-0.5).^2)).*exp(-25((x-t+0.5).^2 + (y-t+0.5).^2))  #  DifferentialEquations.heatProblemExample_birthdeath     Function .  Example problem which starts with 0 and solves with f(u)=1-.1u  #  DifferentialEquations.heatProblemExample_stochasticbirthdeath     Function .  Example problem which starts with 0 and solves with f(u)=1-.1u", 
            "title": "Example Problems"
        }, 
        {
            "location": "/man/problem/#related-functions", 
            "text": "#  DifferentialEquations.PdeProblem     Type .  PdeProblem: Defines PDE problems via its internal functions", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/mesh/", 
            "text": "Mesh Generation\n\n\n\n\nMesh Specification\n\n\n\n\nMesh Type\n\n\n#\n\n\nDifferentialEquations.FEMmesh\n \n \nType\n.\n\n\nFEMmesh\n\n\n#\n\n\nDifferentialEquations.SimpleMesh\n \n \nType\n.\n\n\nSimpleMesh\n\n\n\n\nMesh Generation Functions\n\n\n#\n\n\nDifferentialEquations.findboundary\n \n \nFunction\n.\n\n\nfindboundary(elem,bdFlag=[])\n\n\nfindboundary(femMesh::FEMmesh,bdFlag=[])\n\n\nFinds elements which are on the boundary of the domain. If bdFlag is given, then those indices are added as nodes for a Dirichlet boundary condition (useful for creating cracks and other cutouts of domains).\n\n\nReturns\n\n\nbdNode = Vector of indices for bdNode. Using node[:,bdNode] returns boundary nodes.\n\n\nbdEdge = Vector of indices for boundary edges.\n\n\nisBdNode = Vector of booleans size N which donotes which are on the boundary\n\n\nisBdElem = Vector of booleans size NT which denotes which are on the boundary\n\n\n#\n\n\nDifferentialEquations.setboundary\n \n \nFunction\n.\n\n\nsetboundary(node::AbstractArray,elem::AbstractArray,bdType)\n\n\nsetboundary(femMesh::FEMmesh,bdType)\n\n\nTakes in the femMesh and creates an array bdFlag which denotes the boundary types. 1 stands for Dirichlet, 2 for Neumann, 3 for Robin. \n\n\n#\n\n\nDifferentialEquations.fem_squaremesh\n \n \nFunction\n.\n\n\nfem_squaremesh(square,h)\n\n\nReturns the grid in the iFEM form of the two arrays (node,elem)\n\n\n#\n\n\nDifferentialEquations.notime_squaremesh\n \n \nFunction\n.\n\n\nnotime_squaremesh(square,\u0394x,bdType)\n\n\nComputes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x,\nDirichlet\n)\n\n\n\n\n#\n\n\nDifferentialEquations.parabolic_squaremesh\n \n \nFunction\n.\n\n\nparabolic_squaremesh(square,\u0394x,\u0394t,T,bdType)\n\n\nComputes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.\n\n\nExample\n\n\nsquare=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T,\nDirichlet\n)", 
            "title": "Mesh Generation"
        }, 
        {
            "location": "/man/mesh/#mesh-generation", 
            "text": "", 
            "title": "Mesh Generation"
        }, 
        {
            "location": "/man/mesh/#mesh-specification", 
            "text": "", 
            "title": "Mesh Specification"
        }, 
        {
            "location": "/man/mesh/#mesh-type", 
            "text": "#  DifferentialEquations.FEMmesh     Type .  FEMmesh  #  DifferentialEquations.SimpleMesh     Type .  SimpleMesh", 
            "title": "Mesh Type"
        }, 
        {
            "location": "/man/mesh/#mesh-generation-functions", 
            "text": "#  DifferentialEquations.findboundary     Function .  findboundary(elem,bdFlag=[])  findboundary(femMesh::FEMmesh,bdFlag=[])  Finds elements which are on the boundary of the domain. If bdFlag is given, then those indices are added as nodes for a Dirichlet boundary condition (useful for creating cracks and other cutouts of domains).  Returns  bdNode = Vector of indices for bdNode. Using node[:,bdNode] returns boundary nodes.  bdEdge = Vector of indices for boundary edges.  isBdNode = Vector of booleans size N which donotes which are on the boundary  isBdElem = Vector of booleans size NT which denotes which are on the boundary  #  DifferentialEquations.setboundary     Function .  setboundary(node::AbstractArray,elem::AbstractArray,bdType)  setboundary(femMesh::FEMmesh,bdType)  Takes in the femMesh and creates an array bdFlag which denotes the boundary types. 1 stands for Dirichlet, 2 for Neumann, 3 for Robin.   #  DifferentialEquations.fem_squaremesh     Function .  fem_squaremesh(square,h)  Returns the grid in the iFEM form of the two arrays (node,elem)  #  DifferentialEquations.notime_squaremesh     Function .  notime_squaremesh(square,\u0394x,bdType)  Computes the (node,elem) square mesh for the square with the chosen \u0394x and boundary settings.", 
            "title": "Mesh Generation Functions"
        }, 
        {
            "location": "/man/mesh/#example", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25\nnotime_squaremesh(square,\u0394x, Dirichlet )  #  DifferentialEquations.parabolic_squaremesh     Function .  parabolic_squaremesh(square,\u0394x,\u0394t,T,bdType)  Computes the (node,elem) x [0,T] parabolic square mesh for the square with the chosen \u0394x and boundary settings and with the constant time intervals \u0394t.", 
            "title": "Example"
        }, 
        {
            "location": "/man/mesh/#example_1", 
            "text": "square=[0 1 0 1] #Unit Square\n\u0394x=.25; \u0394t=.25;T=2\nparabolic_squaremesh(square,\u0394x,\u0394t,T, Dirichlet )", 
            "title": "Example"
        }, 
        {
            "location": "/man/solvers/", 
            "text": "Information on Solvers\n\n\n\n\nFinite Element Method Solvers\n\n\n#\n\n\nDifferentialEquations.fem_solvepoisson\n \n \nFunction\n.\n\n\nfem_solvepoisson\n\n\n#\n\n\nDifferentialEquations.fem_solveheat\n \n \nFunction\n.\n\n\nfem_solveheat\n\n\nfem_solveheat(femMesh::FEMmesh,u0::AbstractArray,gD::Function,f::Function,isLinear::Bool)\n\n\nfem_solveheat(femMesh::FEMmesh,u0::Function,gD::Function,f::Function,isLinear::Bool)\n\n\nfem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem)\n\n\nTakes in a definition for the heat equation \nu_t = \u0394u + f\n on a finite element mesh with initial condtion u0 and returns the solution.", 
            "title": "Information on Solvers"
        }, 
        {
            "location": "/man/solvers/#information-on-solvers", 
            "text": "", 
            "title": "Information on Solvers"
        }, 
        {
            "location": "/man/solvers/#finite-element-method-solvers", 
            "text": "#  DifferentialEquations.fem_solvepoisson     Function .  fem_solvepoisson  #  DifferentialEquations.fem_solveheat     Function .  fem_solveheat  fem_solveheat(femMesh::FEMmesh,u0::AbstractArray,gD::Function,f::Function,isLinear::Bool)  fem_solveheat(femMesh::FEMmesh,u0::Function,gD::Function,f::Function,isLinear::Bool)  fem_solveheat(femMesh::FEMmesh,pdeProb::HeatProblem)  Takes in a definition for the heat equation  u_t = \u0394u + f  on a finite element mesh with initial condtion u0 and returns the solution.", 
            "title": "Finite Element Method Solvers"
        }, 
        {
            "location": "/man/solution/", 
            "text": "The Solution Type\n\n\nappxTrue!\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.FEMSolution\n \n \nType\n.\n\n\nFEMSolution\n\n\nA type which holds the data for the solution to a finite element problem.\n\n\n#\n\n\nDifferentialEquations.appxTrue!\n \n \nFunction\n.\n\n\nappxTrue!(res,res2)\n\n\nAdds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution\n\n\n#\n\n\nDifferentialEquations.PdeSolution\n \n \nType\n.\n\n\nPdeSolution: Wrapper for the objects obtained from a PdeSolver", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#the-solution-type", 
            "text": "appxTrue!", 
            "title": "The Solution Type"
        }, 
        {
            "location": "/man/solution/#related-functions", 
            "text": "#  DifferentialEquations.FEMSolution     Type .  FEMSolution  A type which holds the data for the solution to a finite element problem.  #  DifferentialEquations.appxTrue!     Function .  appxTrue!(res,res2)  Adds the solution from res2 to the FEMSolution object res. Useful to add a quasi-true solution when none is known by computing once at a very small time/space step and taking that solution as the \"true\" solution  #  DifferentialEquations.PdeSolution     Type .  PdeSolution: Wrapper for the objects obtained from a PdeSolver", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/plot/", 
            "text": "Plot Functions\n\n\n\n\nRelated Functions\n\n\n#\n\n\nDifferentialEquations.solplot_appxvstrue\n \n \nFunction\n.\n\n\nsolplot_appxvstrue(res::FEMSolution)\n\n\n#\n\n\nDifferentialEquations.solplot_animation\n \n \nFunction\n.\n\n\nsolplot_animation(res::FEMSolution)\n\n\n#\n\n\nDifferentialEquations.convplot\n \n \nFunction\n.\n\n\nconvplot(measure,err)\n\n\n#\n\n\nDifferentialEquations.solplot\n \n \nFunction\n.\n\n\nsolplot(res::FEMSolution)\n\n\n#\n\n\nDifferentialEquations.solplot_appx\n \n \nFunction\n.\n\n\nsolplot_appx(res::FEMSolution)\n\n\n#\n\n\nDifferentialEquations.showmesh\n \n \nFunction\n.\n\n\nshowmesh(femMesh::FEMmesh)", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#plot-functions", 
            "text": "", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/man/plot/#related-functions", 
            "text": "#  DifferentialEquations.solplot_appxvstrue     Function .  solplot_appxvstrue(res::FEMSolution)  #  DifferentialEquations.solplot_animation     Function .  solplot_animation(res::FEMSolution)  #  DifferentialEquations.convplot     Function .  convplot(measure,err)  #  DifferentialEquations.solplot     Function .  solplot(res::FEMSolution)  #  DifferentialEquations.solplot_appx     Function .  solplot_appx(res::FEMSolution)  #  DifferentialEquations.showmesh     Function .  showmesh(femMesh::FEMmesh)", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/convergence/", 
            "text": "Convergence Simulations\n\n\nThe convergence simulation\n\n\n\n\nThe ConvergenceSimulation Type\n\n\n#\n\n\nDifferentialEquations.ConvergenceSimulation\n \n \nType\n.\n\n\nConvergenceSimulation\n\n\nA type which holds the data from a convergence simulation.\n\n\n\n\nRelated Functions\n\n\n#\n\n\nBase.length\n \n \nMethod\n.\n\n\nlength(simres::ConvergenceSimulation)\n\n\nReturns the number of simultations in the Convergence Simulation\n\n\n#\n\n\nDifferentialEquations.conv_ests\n \n \nFunction\n.\n\n\nconv_ests(error::Vector{Number})\n\n\nComputes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via\n\n\nlog2(error[i+1]/error[i])\n\n\nReturns the mean of the convergence estimates\n\n\n\n\nPlot Functions\n\n\n#\n\n\nDifferentialEquations.convplot_full\u0394t\n \n \nFunction\n.\n\n\nconvplot_full\u0394t(simres::ConvergenceSimulation;titleStr=\"All Convergences\",savefile=\"\")\n\n\n#\n\n\nDifferentialEquations.convplot_full\u0394x\n \n \nFunction\n.\n\n\nconvplot_full\u0394x(simres::ConvergenceSimulation;titleStr=\"All Convergences\",savefile=\"\")\n\n\n#\n\n\nDifferentialEquations.convplot_node2vs\u0394t\n \n \nFunction\n.\n\n\nconvplot_node2vs\u0394t(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_maxvs\u0394x\n \n \nFunction\n.\n\n\nconvplot_maxvs\u0394x(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_l2vs\u0394t\n \n \nFunction\n.\n\n\nconvplot_l2vs\u0394t(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_h1vs\u0394t\n \n \nFunction\n.\n\n\nconvplot_h1vs\u0394t(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_l2vs\u0394x\n \n \nFunction\n.\n\n\nconvplot_l2vs\u0394x(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_h1vs\u0394x\n \n \nFunction\n.\n\n\nconvplot_h1vs\u0394x(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_node2vs\u0394x\n \n \nFunction\n.\n\n\nconvplot_node2vs\u0394x(simres::ConvergenceSimulation)\n\n\n#\n\n\nDifferentialEquations.convplot_maxvs\u0394t\n \n \nFunction\n.\n\n\nconvplot_maxvs\u0394t(simres::ConvergenceSimulation)", 
            "title": "Convergence Simuations"
        }, 
        {
            "location": "/man/convergence/#convergence-simulations", 
            "text": "The convergence simulation", 
            "title": "Convergence Simulations"
        }, 
        {
            "location": "/man/convergence/#the-convergencesimulation-type", 
            "text": "#  DifferentialEquations.ConvergenceSimulation     Type .  ConvergenceSimulation  A type which holds the data from a convergence simulation.", 
            "title": "The ConvergenceSimulation Type"
        }, 
        {
            "location": "/man/convergence/#related-functions", 
            "text": "#  Base.length     Method .  length(simres::ConvergenceSimulation)  Returns the number of simultations in the Convergence Simulation  #  DifferentialEquations.conv_ests     Function .  conv_ests(error::Vector{Number})  Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via  log2(error[i+1]/error[i])  Returns the mean of the convergence estimates", 
            "title": "Related Functions"
        }, 
        {
            "location": "/man/convergence/#plot-functions", 
            "text": "#  DifferentialEquations.convplot_full\u0394t     Function .  convplot_full\u0394t(simres::ConvergenceSimulation;titleStr=\"All Convergences\",savefile=\"\")  #  DifferentialEquations.convplot_full\u0394x     Function .  convplot_full\u0394x(simres::ConvergenceSimulation;titleStr=\"All Convergences\",savefile=\"\")  #  DifferentialEquations.convplot_node2vs\u0394t     Function .  convplot_node2vs\u0394t(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_maxvs\u0394x     Function .  convplot_maxvs\u0394x(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_l2vs\u0394t     Function .  convplot_l2vs\u0394t(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_h1vs\u0394t     Function .  convplot_h1vs\u0394t(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_l2vs\u0394x     Function .  convplot_l2vs\u0394x(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_h1vs\u0394x     Function .  convplot_h1vs\u0394x(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_node2vs\u0394x     Function .  convplot_node2vs\u0394x(simres::ConvergenceSimulation)  #  DifferentialEquations.convplot_maxvs\u0394t     Function .  convplot_maxvs\u0394t(simres::ConvergenceSimulation)", 
            "title": "Plot Functions"
        }, 
        {
            "location": "/internals/femTools/", 
            "text": "Internal Finite Element Tools\n\n\n\n\nGeneral\n\n\n#\n\n\nDifferentialEquations\n \n \nModule\n.\n\n\nDifferentialEquations\n\n\nThis is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see \nODE.jl\n\n\nThis package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.\n\n\n\n\nMesh Tools\n\n\n#\n\n\nDifferentialEquations.meshgrid\n \n \nFunction\n.\n\n\nmeshgrid(vx,vy,vz)\n\n\nComputes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.\n\n\nmeshgrid(vx,vy)\n\n\nComputes an (x,y)-grid from the vectors (vx,vy). For more information, see the MATLAB documentation.\n\n\nmeshgrid(vx)\n\n\nComputes an (x,y)-grid from the vectors (vx,vx). For more information, see the MATLAB documentation.\n\n\n#\n\n\nDifferentialEquations.CFL\u03bd\n \n \nFunction\n.\n\n\nCFL\u03bd(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bd= \u0394t/\u0394x\n\n\n#\n\n\nDifferentialEquations.CFL\u03bc\n \n \nFunction\n.\n\n\nCFL\u03bc(\u0394t,\u0394x)\n\n\nComputes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)\n\n\n\n\nSolver Tools\n\n\n#\n\n\nDifferentialEquations.gradbasis\n \n \nFunction\n.\n\n\ngradbasis(node,elem)\n\n\nReturns the gradient of the barycentric basis elements.\n\n\n#\n\n\nDifferentialEquations.quadfbasis\n \n \nFunction\n.\n\n\nquadfbasis(f,gD,gN,A,u,node,elem,area,bdNode,mid,N,Dirichlet,Neumann,isLinear;gNquadorder=2)\n\n\n#\n\n\nDifferentialEquations.quadpts\n \n \nFunction\n.\n\n\nquadpts(order)\n\n\nReturns the quadrature points and weights for and order ### quadrature in 2D.\n\n\n#\n\n\nDifferentialEquations.accumarray\n \n \nFunction\n.\n\n\naccumarray(subs, val, sz=(maximum(subs),))\n\n\nSee MATLAB's documentation for more details.\n\n\n#\n\n\nDifferentialEquations.assemblematrix\n \n \nFunction\n.\n\n\nassemblematrix(node,elem;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\nassemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])\n\n\nAssembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.\n\n\nReturns\n\n\nA = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.\n\n\n#\n\n\nDifferentialEquations.gradu\n \n \nFunction\n.\n\n\ngradu(node,elem,u,Dlambda=[])\n\n\nEstimates the gradient of u on the mesh (node,elem)\n\n\n\n\nError Tools\n\n\n#\n\n\nDifferentialEquations.getH1error\n \n \nFunction\n.\n\n\nfunction getH1error(node,elem,Du,uh,K=[],quadOrder=[])\n\n\ngetH1error(femMesh::FEMmesh,Du,u)\n\n\nEstimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature order unless specified. If K is specified then it is the diffusion coefficient matrix.\n\n\n#\n\n\nDifferentialEquations.getL2error\n \n \nFunction\n.\n\n\ngetL2error(node,elem,uexact,uh,quadOrder=[])\n\n\ngetL2error(femMesh::FEMmesh,sol,u)\n\n\nEstimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature order unless specified.", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/femTools/#internal-finite-element-tools", 
            "text": "", 
            "title": "Internal Finite Element Tools"
        }, 
        {
            "location": "/internals/femTools/#general", 
            "text": "#  DifferentialEquations     Module .", 
            "title": "General"
        }, 
        {
            "location": "/internals/femTools/#differentialequations", 
            "text": "This is a package for solving numerically solving differential equations in Julia by Chris Rackauckas. The purpose of this package is to supply efficient Julia implementations of solvers for various differential equations. Equations within the realm of this package include stochastic ordinary differential equations (SODEs or SDEs), stochastic partial differential equations (SPDEs), partial differential equations (with both finite difference and finite element methods), and differential delay equations. For ordinary differential equation solvers, see  ODE.jl  This package is for efficient and parallel implementations of research-level algorithms, many of which are quite recent. These algorithms aim to be optimized for HPC applications, including the use of GPUs, Xeon Phis, and multi-node parallelism. With the easy to use plot/convergence testing algorithms, this package also provides a good sandbox for developing novel numerical schemes.", 
            "title": "DifferentialEquations"
        }, 
        {
            "location": "/internals/femTools/#mesh-tools", 
            "text": "#  DifferentialEquations.meshgrid     Function .  meshgrid(vx,vy,vz)  Computes an (x,y,z)-grid from the vectors (vx,vy,vz). For more information, see the MATLAB documentation.  meshgrid(vx,vy)  Computes an (x,y)-grid from the vectors (vx,vy). For more information, see the MATLAB documentation.  meshgrid(vx)  Computes an (x,y)-grid from the vectors (vx,vx). For more information, see the MATLAB documentation.  #  DifferentialEquations.CFL\u03bd     Function .  CFL\u03bd(\u0394t,\u0394x)  Computes the CFL-condition \u03bd= \u0394t/\u0394x  #  DifferentialEquations.CFL\u03bc     Function .  CFL\u03bc(\u0394t,\u0394x)  Computes the CFL-condition \u03bc= \u0394t/(\u0394x*\u0394x)", 
            "title": "Mesh Tools"
        }, 
        {
            "location": "/internals/femTools/#solver-tools", 
            "text": "#  DifferentialEquations.gradbasis     Function .  gradbasis(node,elem)  Returns the gradient of the barycentric basis elements.  #  DifferentialEquations.quadfbasis     Function .  quadfbasis(f,gD,gN,A,u,node,elem,area,bdNode,mid,N,Dirichlet,Neumann,isLinear;gNquadorder=2)  #  DifferentialEquations.quadpts     Function .  quadpts(order)  Returns the quadrature points and weights for and order ### quadrature in 2D.  #  DifferentialEquations.accumarray     Function .  accumarray(subs, val, sz=(maximum(subs),))  See MATLAB's documentation for more details.  #  DifferentialEquations.assemblematrix     Function .  assemblematrix(node,elem;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  assemblematrix(FEMmesh::FEMmesh;lumpflag=false,K=[])  Assembles the stiffness matrix A as an approximation to \u0394 on the finite element mesh (node,elem). Also generates the mass matrix M. If lumpflag=true, then the mass matrix is lumped resulting in a diagonal mass matrix. Specify a diffusion constant along the nodes via K.  Returns  A = Stiffness Matrix M = Mass Matrix area = A vector of the calculated areas for each element.  #  DifferentialEquations.gradu     Function .  gradu(node,elem,u,Dlambda=[])  Estimates the gradient of u on the mesh (node,elem)", 
            "title": "Solver Tools"
        }, 
        {
            "location": "/internals/femTools/#error-tools", 
            "text": "#  DifferentialEquations.getH1error     Function .  function getH1error(node,elem,Du,uh,K=[],quadOrder=[])  getH1error(femMesh::FEMmesh,Du,u)  Estimates the H1 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature order unless specified. If K is specified then it is the diffusion coefficient matrix.  #  DifferentialEquations.getL2error     Function .  getL2error(node,elem,uexact,uh,quadOrder=[])  getL2error(femMesh::FEMmesh,sol,u)  Estimates the L2 error between uexact and uh on the mesh (node,elem). It reads the mesh to estimate the element type and uses this to choose a quadrature order unless specified.", 
            "title": "Error Tools"
        }, 
        {
            "location": "/internals/extras/", 
            "text": "Extra Functions\n\n\n#\n\n\nDifferentialEquations.quadfbasis2\n \n \nFunction\n.\n\n\nquadfbasis2(f,gD,A,node,elem,lambda,phi,weight,N,NT,area,bdNode) Slightly slower than quadfbasis, easier to extend to higher order quadrature\n\n\n#\n\n\nDifferentialEquations.CG2\n \n \nFunction\n.\n\n\nCG2(u,A,b;tol=1e-6)\n\n\n#\n\n\nDifferentialEquations.modulechildren\n \n \nFunction\n.\n\n\nmodulechildren(m::Module)\n\n\nReturns the modules in m\n\n\n#\n\n\nDifferentialEquations.checkIfLoaded\n \n \nFunction\n.\n\n\ncheckIfLoaded(pkg::AbstractString)\n\n\nReturns true if module \"pkg\" is defined in Main, otherwise false.", 
            "title": "Extra Functions"
        }, 
        {
            "location": "/internals/extras/#extra-functions", 
            "text": "#  DifferentialEquations.quadfbasis2     Function .  quadfbasis2(f,gD,A,node,elem,lambda,phi,weight,N,NT,area,bdNode) Slightly slower than quadfbasis, easier to extend to higher order quadrature  #  DifferentialEquations.CG2     Function .  CG2(u,A,b;tol=1e-6)  #  DifferentialEquations.modulechildren     Function .  modulechildren(m::Module)  Returns the modules in m  #  DifferentialEquations.checkIfLoaded     Function .  checkIfLoaded(pkg::AbstractString)  Returns true if module \"pkg\" is defined in Main, otherwise false.", 
            "title": "Extra Functions"
        }
    ]
}